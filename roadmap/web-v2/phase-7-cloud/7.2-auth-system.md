# Feature 7.2: Authentication System (Web)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | WEB-7.2 |
| **Phase** | 7 - Cloud Infrastructure (Web) |
| **Priority** | Critical |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | WEB-7.1 (Cloud Database) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement authentication system using NextAuth.js with email/password, Google OAuth, and session management backed by Supabase PostgreSQL.

## User Story

As a **web user**, I want **secure authentication with multiple sign-in options** so that **I can access my business data from any device**.

---

## Requirements

### Functional
1. Email/password authentication
2. Google OAuth integration
3. Email verification
4. Password reset flow
5. Session management
6. Protected API routes
7. User profile management

### Non-Functional
- Secure password hashing (bcrypt)
- JWT-based sessions
- CSRF protection
- Rate limiting on auth endpoints
- GDPR-compliant data handling
- 99.9% auth service uptime

---

## Technical Specification

### NextAuth.js Configuration

```typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth, { NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import GoogleProvider from 'next-auth/providers/google';
import { SupabaseAdapter } from '@next-auth/supabase-adapter';
import { createClient } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export const authOptions: NextAuthOptions = {
  adapter: SupabaseAdapter({
    url: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    secret: process.env.SUPABASE_SERVICE_ROLE_KEY!
  }),

  providers: [
    CredentialsProvider({
      name: 'Email',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Missing credentials');
        }

        // Find user
        const { data: user } = await supabase
          .from('users')
          .select('*')
          .eq('email', credentials.email)
          .single();

        if (!user) {
          throw new Error('No user found with this email');
        }

        // Verify password
        const isValid = await bcrypt.compare(credentials.password, user.password_hash);

        if (!isValid) {
          throw new Error('Invalid password');
        }

        // Check email verification
        if (!user.email_verified) {
          throw new Error('Please verify your email first');
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          image: user.avatar_url
        };
      }
    }),

    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!
    })
  ],

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60 // 30 days
  },

  callbacks: {
    async jwt({ token, user, account }) {
      if (user) {
        token.id = user.id;
      }

      return token;
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
      }

      return session;
    }
  },

  pages: {
    signIn: '/auth/signin',
    signOut: '/auth/signout',
    error: '/auth/error',
    verifyRequest: '/auth/verify-request',
    newUser: '/onboarding'
  }
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };
```

### Sign Up Flow

```typescript
// app/api/auth/signup/route.ts
import { NextRequest, NextResponse } from 'next/server';
import bcrypt from 'bcryptjs';
import { createClient } from '@supabase/supabase-js';
import { sendVerificationEmail } from '@/lib/email';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(req: NextRequest) {
  const { email, password, name } = await req.json();

  // Validation
  if (!email || !password || !name) {
    return NextResponse.json(
      { error: 'Missing required fields' },
      { status: 400 }
    );
  }

  if (password.length < 8) {
    return NextResponse.json(
      { error: 'Password must be at least 8 characters' },
      { status: 400 }
    );
  }

  // Check if user exists
  const { data: existingUser } = await supabase
    .from('users')
    .select('id')
    .eq('email', email)
    .single();

  if (existingUser) {
    return NextResponse.json(
      { error: 'User with this email already exists' },
      { status: 400 }
    );
  }

  // Hash password
  const passwordHash = await bcrypt.hash(password, 10);

  // Create user
  const { data: user, error } = await supabase
    .from('users')
    .insert({
      email,
      name,
      password_hash: passwordHash,
      email_verified: false,
      created_at: new Date().toISOString()
    })
    .select()
    .single();

  if (error) {
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    );
  }

  // Generate verification token
  const verificationToken = generateToken();

  await supabase
    .from('verification_tokens')
    .insert({
      user_id: user.id,
      token: verificationToken,
      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // 24h
    });

  // Send verification email
  await sendVerificationEmail(email, verificationToken);

  return NextResponse.json({
    message: 'User created. Please check your email to verify your account.',
    userId: user.id
  });
}

function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}
```

### Email Verification

```typescript
// app/api/auth/verify/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(req: NextRequest) {
  const token = req.nextUrl.searchParams.get('token');

  if (!token) {
    return NextResponse.redirect('/auth/error?error=InvalidToken');
  }

  // Find verification token
  const { data: verificationToken } = await supabase
    .from('verification_tokens')
    .select('*')
    .eq('token', token)
    .single();

  if (!verificationToken) {
    return NextResponse.redirect('/auth/error?error=InvalidToken');
  }

  // Check expiration
  if (new Date(verificationToken.expires_at) < new Date()) {
    return NextResponse.redirect('/auth/error?error=TokenExpired');
  }

  // Update user
  await supabase
    .from('users')
    .update({ email_verified: true })
    .eq('id', verificationToken.user_id);

  // Delete token
  await supabase
    .from('verification_tokens')
    .delete()
    .eq('id', verificationToken.id);

  return NextResponse.redirect('/auth/signin?verified=true');
}
```

### Password Reset Flow

```typescript
// app/api/auth/forgot-password/route.ts
export async function POST(req: NextRequest) {
  const { email } = await req.json();

  const { data: user } = await supabase
    .from('users')
    .select('id')
    .eq('email', email)
    .single();

  if (!user) {
    // Don't reveal if user exists (security)
    return NextResponse.json({
      message: 'If an account exists, you will receive a password reset email.'
    });
  }

  // Generate reset token
  const resetToken = generateToken();

  await supabase
    .from('password_reset_tokens')
    .insert({
      user_id: user.id,
      token: resetToken,
      expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString() // 1h
    });

  await sendPasswordResetEmail(email, resetToken);

  return NextResponse.json({
    message: 'If an account exists, you will receive a password reset email.'
  });
}

// app/api/auth/reset-password/route.ts
export async function POST(req: NextRequest) {
  const { token, newPassword } = await req.json();

  const { data: resetToken } = await supabase
    .from('password_reset_tokens')
    .select('*')
    .eq('token', token)
    .single();

  if (!resetToken || new Date(resetToken.expires_at) < new Date()) {
    return NextResponse.json(
      { error: 'Invalid or expired token' },
      { status: 400 }
    );
  }

  // Hash new password
  const passwordHash = await bcrypt.hash(newPassword, 10);

  // Update user
  await supabase
    .from('users')
    .update({ password_hash: passwordHash })
    .eq('id', resetToken.user_id);

  // Delete token
  await supabase
    .from('password_reset_tokens')
    .delete()
    .eq('id', resetToken.id);

  return NextResponse.json({ message: 'Password reset successful' });
}
```

### Protected API Routes

```typescript
// lib/auth.ts
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { NextRequest, NextResponse } from 'next/server';

export async function requireAuth() {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new Error('Unauthorized');
  }

  return session.user;
}

export function withAuth(handler: (req: NextRequest, userId: string) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    try {
      const user = await requireAuth();
      return handler(req, user.id);
    } catch (error) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
  };
}

// Usage in API route
// app/api/businesses/route.ts
export const GET = withAuth(async (req, userId) => {
  const businesses = await getBusinessesByUserId(userId);
  return NextResponse.json(businesses);
});
```

### Client-Side Auth Hooks

```typescript
// hooks/useAuth.ts
import { useSession, signIn, signOut } from 'next-auth/react';

export function useAuth() {
  const { data: session, status } = useSession();

  return {
    user: session?.user,
    isAuthenticated: status === 'authenticated',
    isLoading: status === 'loading',
    signIn,
    signOut
  };
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Set up NextAuth.js | 45 min |
| Implement email/password auth | 60 min |
| Add Google OAuth | 30 min |
| Create sign up flow | 45 min |
| Implement email verification | 45 min |
| Add password reset flow | 45 min |
| Protect API routes | 30 min |
| Write tests | 40 min |

---

## Acceptance Criteria
- [ ] Email/password sign up works
- [ ] Email verification required
- [ ] Google OAuth sign in works
- [ ] Password reset flow works
- [ ] Sessions persist across devices
- [ ] Protected routes redirect to sign in
- [ ] Rate limiting on auth endpoints

---

## Database Schema

```sql
-- Already in WEB-7.1 (Cloud Database), included here for reference

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255) NOT NULL,
  password_hash VARCHAR(255), -- Null for OAuth users
  email_verified BOOLEAN DEFAULT FALSE,
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE verification_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(255) UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE password_reset_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(255) UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

---

## Dependencies

```json
{
  "next-auth": "^4.24.0",
  "@next-auth/supabase-adapter": "^1.0.0",
  "bcryptjs": "^2.4.3",
  "@types/bcryptjs": "^2.4.2"
}
```

---

## Environment Variables

```env
# NextAuth
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=your-secret-key

# Google OAuth
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Supabase
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```
