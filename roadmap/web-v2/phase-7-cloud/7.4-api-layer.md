# Feature 7.4: REST API Layer (Web)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | WEB-7.4 |
| **Phase** | 7 - Cloud Infrastructure (Web) |
| **Priority** | Critical |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | WEB-7.1 (Cloud Database), WEB-7.2 (Auth System) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement comprehensive REST API for all business operations using Next.js App Router API routes with authentication, validation, error handling, and rate limiting.

## User Story

As a **web/mobile developer**, I want **a clean REST API** so that **I can build consistent frontend experiences across web and mobile**.

---

## Requirements

### Functional
1. CRUD endpoints for businesses, conversations, messages
2. Workflow management endpoints
3. Search endpoints (semantic + keyword)
4. Data export endpoints
5. User profile endpoints
6. Request/response validation
7. Pagination support

### Non-Functional
- Response time < 200ms (p95)
- Rate limiting (100 req/min per user)
- Proper HTTP status codes
- JSON error responses
- OpenAPI/Swagger documentation
- CORS configuration

---

## Technical Specification

### API Route Structure

```
app/api/
├── auth/                    # Authentication (NextAuth)
│   ├── [...nextauth]/
│   ├── signup/
│   └── verify/
├── businesses/              # Business CRUD
│   ├── route.ts            # GET (list), POST (create)
│   └── [id]/
│       ├── route.ts        # GET, PATCH, DELETE
│       └── context/
│           └── route.ts    # PATCH (update context)
├── conversations/           # Conversation CRUD
│   ├── route.ts
│   └── [id]/
│       ├── route.ts
│       └── messages/
│           └── route.ts    # GET (list), POST (create)
├── messages/
│   └── [id]/
│       └── route.ts        # GET, DELETE
├── workflows/               # Workflow management
│   ├── route.ts            # GET (list)
│   ├── [id]/
│   │   └── route.ts        # GET (definition)
│   └── executions/
│       ├── route.ts        # POST (start)
│       └── [id]/
│           ├── route.ts    # GET (status), DELETE (cancel)
│           └── steps/
│               └── [stepId]/
│                   └── route.ts  # POST (complete)
├── search/
│   └── route.ts            # POST (semantic search)
├── export/
│   └── route.ts            # GET (export data)
└── user/
    └── profile/
        └── route.ts        # GET, PATCH
```

### Base API Utils

```typescript
// lib/api/utils.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

export class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = 'APIError';
  }
}

export function handleAPIError(error: unknown): NextResponse {
  console.error('API Error:', error);

  if (error instanceof APIError) {
    return NextResponse.json(
      {
        error: error.message,
        code: error.code
      },
      { status: error.statusCode }
    );
  }

  if (error instanceof z.ZodError) {
    return NextResponse.json(
      {
        error: 'Validation error',
        details: error.errors
      },
      { status: 400 }
    );
  }

  return NextResponse.json(
    { error: 'Internal server error' },
    { status: 500 }
  );
}

export async function validateBody<T>(
  req: NextRequest,
  schema: z.ZodSchema<T>
): Promise<T> {
  try {
    const body = await req.json();
    return schema.parse(body);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new APIError('Validation error', 400);
    }
    throw error;
  }
}

export function createPaginationParams(req: NextRequest) {
  const url = new URL(req.url);
  const page = parseInt(url.searchParams.get('page') || '1');
  const limit = parseInt(url.searchParams.get('limit') || '20');
  const offset = (page - 1) * limit;

  return { page, limit, offset };
}

export function createPaginatedResponse<T>(
  data: T[],
  total: number,
  page: number,
  limit: number
) {
  return {
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrevious: page > 1
    }
  };
}
```

### Businesses API

```typescript
// app/api/businesses/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { withAuth } from '@/lib/auth';
import { handleAPIError, validateBody } from '@/lib/api/utils';
import { BusinessRepository } from '@/infrastructure/repositories/business.repository';

const CreateBusinessSchema = z.object({
  name: z.string().min(1).max(255),
  industry: z.string().optional(),
  stage: z.enum(['idea', 'validation', 'mvp', 'growth', 'scale']).optional()
});

export const GET = withAuth(async (req, userId) => {
  try {
    const businessRepo = new BusinessRepository();
    const businesses = await businessRepo.findByUserId(userId);

    return NextResponse.json(businesses);
  } catch (error) {
    return handleAPIError(error);
  }
});

export const POST = withAuth(async (req, userId) => {
  try {
    const data = await validateBody(req, CreateBusinessSchema);

    const businessRepo = new BusinessRepository();
    const business = await businessRepo.create({
      userId,
      ...data
    });

    return NextResponse.json(business, { status: 201 });
  } catch (error) {
    return handleAPIError(error);
  }
});

// app/api/businesses/[id]/route.ts
export const GET = withAuth(async (req, userId, { params }) => {
  try {
    const { id } = params;
    const businessRepo = new BusinessRepository();

    const business = await businessRepo.findById(id);

    if (!business || business.user_id !== userId) {
      throw new APIError('Business not found', 404);
    }

    return NextResponse.json(business);
  } catch (error) {
    return handleAPIError(error);
  }
});

const UpdateBusinessSchema = z.object({
  name: z.string().min(1).max(255).optional(),
  industry: z.string().optional(),
  stage: z.enum(['idea', 'validation', 'mvp', 'growth', 'scale']).optional()
});

export const PATCH = withAuth(async (req, userId, { params }) => {
  try {
    const { id } = params;
    const data = await validateBody(req, UpdateBusinessSchema);

    const businessRepo = new BusinessRepository();
    const business = await businessRepo.findById(id);

    if (!business || business.user_id !== userId) {
      throw new APIError('Business not found', 404);
    }

    const updated = await businessRepo.update(id, data);

    return NextResponse.json(updated);
  } catch (error) {
    return handleAPIError(error);
  }
});

export const DELETE = withAuth(async (req, userId, { params }) => {
  try {
    const { id } = params;
    const businessRepo = new BusinessRepository();

    const business = await businessRepo.findById(id);

    if (!business || business.user_id !== userId) {
      throw new APIError('Business not found', 404);
    }

    await businessRepo.delete(id);

    return NextResponse.json({ success: true }, { status: 204 });
  } catch (error) {
    return handleAPIError(error);
  }
});
```

### Conversations API

```typescript
// app/api/conversations/route.ts
export const GET = withAuth(async (req, userId) => {
  try {
    const url = new URL(req.url);
    const businessId = url.searchParams.get('businessId');

    if (!businessId) {
      throw new APIError('businessId query parameter required', 400);
    }

    // Verify business ownership
    const businessRepo = new BusinessRepository();
    const business = await businessRepo.findById(businessId);

    if (!business || business.user_id !== userId) {
      throw new APIError('Business not found', 404);
    }

    const { page, limit, offset } = createPaginationParams(req);

    const conversationRepo = new ConversationRepository();
    const conversations = await conversationRepo.findByBusinessId(
      businessId,
      { limit, offset }
    );

    const total = await conversationRepo.countByBusinessId(businessId);

    return NextResponse.json(
      createPaginatedResponse(conversations, total, page, limit)
    );
  } catch (error) {
    return handleAPIError(error);
  }
});

const CreateConversationSchema = z.object({
  businessId: z.string().uuid(),
  title: z.string().optional()
});

export const POST = withAuth(async (req, userId) => {
  try {
    const data = await validateBody(req, CreateConversationSchema);

    // Verify business ownership
    const businessRepo = new BusinessRepository();
    const business = await businessRepo.findById(data.businessId);

    if (!business || business.user_id !== userId) {
      throw new APIError('Business not found', 404);
    }

    const conversationRepo = new ConversationRepository();
    const conversation = await conversationRepo.create(data.businessId);

    if (data.title) {
      await conversationRepo.updateTitle(conversation.id, data.title);
    }

    return NextResponse.json(conversation, { status: 201 });
  } catch (error) {
    return handleAPIError(error);
  }
});
```

### Messages API

```typescript
// app/api/conversations/[id]/messages/route.ts
export const GET = withAuth(async (req, userId, { params }) => {
  try {
    const { id: conversationId } = params;

    // Verify conversation ownership
    await verifyConversationOwnership(conversationId, userId);

    const { page, limit, offset } = createPaginationParams(req);

    const messageRepo = new MessageRepository();
    const messages = await messageRepo.findByConversationId(
      conversationId,
      { limit, offset }
    );

    const total = await messageRepo.countByConversationId(conversationId);

    return NextResponse.json(
      createPaginatedResponse(messages, total, page, limit)
    );
  } catch (error) {
    return handleAPIError(error);
  }
});

const CreateMessageSchema = z.object({
  role: z.enum(['user', 'assistant']),
  content: z.string().min(1)
});

export const POST = withAuth(async (req, userId, { params }) => {
  try {
    const { id: conversationId } = params;
    const data = await validateBody(req, CreateMessageSchema);

    await verifyConversationOwnership(conversationId, userId);

    const messageRepo = new MessageRepository();
    const message = await messageRepo.create({
      conversationId,
      ...data
    });

    // If user message, trigger AI response in background
    if (data.role === 'user') {
      handleUserMessage(conversationId, message.id).catch(err =>
        console.error('AI response failed:', err)
      );
    }

    return NextResponse.json(message, { status: 201 });
  } catch (error) {
    return handleAPIError(error);
  }
});

async function verifyConversationOwnership(
  conversationId: string,
  userId: string
): Promise<void> {
  const conversationRepo = new ConversationRepository();
  const conversation = await conversationRepo.findById(conversationId);

  if (!conversation) {
    throw new APIError('Conversation not found', 404);
  }

  const businessRepo = new BusinessRepository();
  const business = await businessRepo.findById(conversation.business_id);

  if (!business || business.user_id !== userId) {
    throw new APIError('Unauthorized', 403);
  }
}
```

### Search API

```typescript
// app/api/search/route.ts
const SearchSchema = z.object({
  query: z.string().min(1),
  businessId: z.string().uuid().optional(),
  sourceTypes: z.array(z.enum(['message', 'business_context'])).optional(),
  limit: z.number().min(1).max(50).default(10),
  threshold: z.number().min(0).max(1).default(0.7)
});

export const POST = withAuth(async (req, userId) => {
  try {
    const data = await validateBody(req, SearchSchema);

    // If businessId provided, verify ownership
    if (data.businessId) {
      const businessRepo = new BusinessRepository();
      const business = await businessRepo.findById(data.businessId);

      if (!business || business.user_id !== userId) {
        throw new APIError('Business not found', 404);
      }
    }

    const retrievalService = new RetrievalService();
    const results = await retrievalService.search(data.query, {
      businessId: data.businessId,
      sourceTypes: data.sourceTypes,
      limit: data.limit,
      threshold: data.threshold
    });

    return NextResponse.json({ results });
  } catch (error) {
    return handleAPIError(error);
  }
});
```

### Rate Limiting Middleware

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { RateLimiter } from './lib/rate-limiter';

const limiter = new RateLimiter({
  windowMs: 60 * 1000, // 1 minute
  maxRequests: 100
});

export async function middleware(request: NextRequest) {
  const userId = request.headers.get('x-user-id');

  if (request.nextUrl.pathname.startsWith('/api/')) {
    if (userId) {
      const allowed = await limiter.checkLimit(userId);

      if (!allowed) {
        return NextResponse.json(
          { error: 'Rate limit exceeded' },
          { status: 429 }
        );
      }
    }
  }

  return NextResponse.next();
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create API utils & error handling | 30 min |
| Implement Businesses API | 45 min |
| Implement Conversations API | 45 min |
| Implement Messages API | 45 min |
| Implement Search API | 30 min |
| Add rate limiting | 30 min |
| Write API tests | 60 min |

---

## Acceptance Criteria
- [ ] All CRUD endpoints work
- [ ] Request validation with Zod
- [ ] Proper error responses
- [ ] Rate limiting (100 req/min)
- [ ] Pagination support
- [ ] Response time < 200ms (p95)
- [ ] API documentation complete

---

## Dependencies

```json
{
  "zod": "^3.22.0",
  "@supabase/supabase-js": "^2.38.0"
}
```

---

## API Documentation

Use TypeDoc or Swagger for auto-generated docs:

```typescript
// Generate OpenAPI spec
// npm install swagger-jsdoc swagger-ui-express
```
