# Feature 7.3: Multi-Device Sync Engine (Web)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | WEB-7.3 |
| **Phase** | 7 - Cloud Infrastructure (Web) |
| **Priority** | Critical |
| **Estimated Effort** | 5-6 hours |
| **Dependencies** | WEB-7.1 (Cloud Database), WEB-7.2 (Auth System) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement real-time data synchronization across web and mobile devices using Supabase Realtime, ensuring consistent state and optimistic UI updates with conflict resolution.

## User Story

As a **web/mobile user**, I want **my data to sync across all my devices in real-time** so that **I can seamlessly switch between laptop, phone, and tablet**.

---

## Requirements

### Functional
1. Real-time sync for conversations, messages, businesses
2. Optimistic UI updates (instant feedback)
3. Conflict resolution (last-write-wins with timestamps)
4. Offline support (queue changes, sync when online)
5. Sync status indicators
6. Initial data sync on login

### Non-Functional
- Sync latency < 500ms
- Support 10+ concurrent devices per user
- Handle network interruptions gracefully
- 99.9% data consistency
- Efficient bandwidth usage (delta sync)

---

## Technical Specification

### Sync Architecture

```typescript
// lib/sync/sync-engine.ts
import { createClient, RealtimeChannel } from '@supabase/supabase-js';
import { EventEmitter } from 'events';

export interface SyncEvent {
  table: string;
  eventType: 'INSERT' | 'UPDATE' | 'DELETE';
  old?: any;
  new?: any;
  timestamp: string;
}

export class SyncEngine extends EventEmitter {
  private supabase;
  private channels: Map<string, RealtimeChannel> = new Map();
  private userId: string;
  private isOnline: boolean = true;
  private syncQueue: SyncEvent[] = [];

  constructor(userId: string) {
    super();
    this.userId = userId;

    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    // Monitor online/offline status
    if (typeof window !== 'undefined') {
      window.addEventListener('online', () => this.handleOnline());
      window.addEventListener('offline', () => this.handleOffline());
      this.isOnline = navigator.onLine;
    }
  }

  async startSync() {
    // Subscribe to all relevant tables for this user
    await this.subscribeToBusinesses();
    await this.subscribeToConversations();
    await this.subscribeToMessages();

    // Sync queued changes if coming back online
    if (this.isOnline && this.syncQueue.length > 0) {
      await this.processSyncQueue();
    }
  }

  async stopSync() {
    // Unsubscribe from all channels
    for (const [name, channel] of this.channels) {
      await this.supabase.removeChannel(channel);
      this.channels.delete(name);
    }
  }

  private async subscribeToBusinesses() {
    const channel = this.supabase
      .channel('businesses-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'businesses',
          filter: `user_id=eq.${this.userId}`
        },
        (payload) => this.handleBusinessChange(payload)
      )
      .subscribe();

    this.channels.set('businesses', channel);
  }

  private async subscribeToConversations() {
    // Get all business IDs for this user
    const { data: businesses } = await this.supabase
      .from('businesses')
      .select('id')
      .eq('user_id', this.userId);

    const businessIds = businesses?.map(b => b.id) || [];

    const channel = this.supabase
      .channel('conversations-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'conversations'
        },
        (payload) => {
          // Filter client-side for business ownership
          if (businessIds.includes(payload.new?.business_id || payload.old?.business_id)) {
            this.handleConversationChange(payload);
          }
        }
      )
      .subscribe();

    this.channels.set('conversations', channel);
  }

  private async subscribeToMessages() {
    // Subscribe to messages in user's conversations
    const channel = this.supabase
      .channel('messages-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'messages'
        },
        (payload) => this.handleMessageChange(payload)
      )
      .subscribe();

    this.channels.set('messages', channel);
  }

  private handleBusinessChange(payload: any) {
    const syncEvent: SyncEvent = {
      table: 'businesses',
      eventType: payload.eventType,
      old: payload.old,
      new: payload.new,
      timestamp: new Date().toISOString()
    };

    this.emit('sync:business', syncEvent);
  }

  private handleConversationChange(payload: any) {
    const syncEvent: SyncEvent = {
      table: 'conversations',
      eventType: payload.eventType,
      old: payload.old,
      new: payload.new,
      timestamp: new Date().toISOString()
    };

    this.emit('sync:conversation', syncEvent);
  }

  private handleMessageChange(payload: any) {
    const syncEvent: SyncEvent = {
      table: 'messages',
      eventType: payload.eventType,
      old: payload.old,
      new: payload.new,
      timestamp: new Date().toISOString()
    };

    this.emit('sync:message', syncEvent);
  }

  private handleOnline() {
    this.isOnline = true;
    this.emit('sync:online');
    this.processSyncQueue();
  }

  private handleOffline() {
    this.isOnline = false;
    this.emit('sync:offline');
  }

  async queueChange(change: SyncEvent) {
    this.syncQueue.push(change);

    if (this.isOnline) {
      await this.processSyncQueue();
    }
  }

  private async processSyncQueue() {
    while (this.syncQueue.length > 0 && this.isOnline) {
      const change = this.syncQueue.shift()!;

      try {
        await this.applyChange(change);
        this.emit('sync:success', change);
      } catch (error) {
        console.error('Sync failed:', error);
        this.syncQueue.unshift(change); // Re-queue
        this.emit('sync:error', error);
        break; // Stop processing on error
      }
    }
  }

  private async applyChange(change: SyncEvent) {
    switch (change.eventType) {
      case 'INSERT':
        await this.supabase.from(change.table).insert(change.new);
        break;

      case 'UPDATE':
        await this.supabase
          .from(change.table)
          .update(change.new)
          .eq('id', change.new.id);
        break;

      case 'DELETE':
        await this.supabase
          .from(change.table)
          .delete()
          .eq('id', change.old.id);
        break;
    }
  }
}
```

### React Integration

```typescript
// hooks/useSync.ts
import { useEffect, useState } from 'react';
import { useAuth } from './useAuth';
import { SyncEngine } from '@/lib/sync/sync-engine';

export function useSync() {
  const { user } = useAuth();
  const [syncEngine, setSyncEngine] = useState<SyncEngine | null>(null);
  const [isSyncing, setIsSyncing] = useState(false);
  const [isOnline, setIsOnline] = useState(true);
  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);

  useEffect(() => {
    if (!user) return;

    const engine = new SyncEngine(user.id);

    engine.on('sync:business', handleBusinessSync);
    engine.on('sync:conversation', handleConversationSync);
    engine.on('sync:message', handleMessageSync);
    engine.on('sync:online', () => setIsOnline(true));
    engine.on('sync:offline', () => setIsOnline(false));

    engine.startSync();
    setSyncEngine(engine);

    return () => {
      engine.stopSync();
    };
  }, [user]);

  const handleBusinessSync = (event: SyncEvent) => {
    setLastSyncTime(new Date());
    // Update local state (Zustand/Redux)
    // ... implementation
  };

  const handleConversationSync = (event: SyncEvent) => {
    setLastSyncTime(new Date());
    // ... implementation
  };

  const handleMessageSync = (event: SyncEvent) => {
    setLastSyncTime(new Date());
    // ... implementation
  };

  return {
    syncEngine,
    isSyncing,
    isOnline,
    lastSyncTime
  };
}
```

### Optimistic Updates

```typescript
// lib/sync/optimistic-updates.ts
export class OptimisticUpdateManager {
  private pendingUpdates: Map<string, any> = new Map();

  async applyOptimisticUpdate<T>(
    id: string,
    updateFn: () => Promise<T>,
    rollbackFn: () => void
  ): Promise<T> {
    // Apply update optimistically (UI updates immediately)
    const optimisticId = `${id}-${Date.now()}`;
    this.pendingUpdates.set(optimisticId, { rollbackFn });

    try {
      const result = await updateFn();

      // Remove pending update on success
      this.pendingUpdates.delete(optimisticId);

      return result;
    } catch (error) {
      // Rollback on failure
      rollbackFn();
      this.pendingUpdates.delete(optimisticId);

      throw error;
    }
  }
}

// Usage in component
const sendMessage = async (content: string) => {
  const tempMessage = {
    id: `temp-${Date.now()}`,
    content,
    role: 'user',
    created_at: Date.now()
  };

  // Optimistically add to UI
  addMessageToUI(tempMessage);

  await optimisticManager.applyOptimisticUpdate(
    tempMessage.id,
    async () => {
      // Actual API call
      const result = await api.createMessage({ content });

      // Replace temp message with real one
      replaceMessageInUI(tempMessage.id, result);

      return result;
    },
    () => {
      // Rollback: remove temp message
      removeMessageFromUI(tempMessage.id);
    }
  );
};
```

### Conflict Resolution

```typescript
// lib/sync/conflict-resolver.ts
export class ConflictResolver {
  resolve(local: any, remote: any): any {
    // Last-write-wins based on updated_at timestamp
    const localTime = new Date(local.updated_at).getTime();
    const remoteTime = new Date(remote.updated_at).getTime();

    if (remoteTime > localTime) {
      console.log('Conflict: Remote wins');
      return remote;
    } else if (localTime > remoteTime) {
      console.log('Conflict: Local wins');
      return local;
    } else {
      // Timestamps equal, prefer remote (server is source of truth)
      return remote;
    }
  }

  // For specific fields, use custom merge strategies
  mergeBusinessContext(local: any, remote: any): any {
    return {
      ...remote,
      context: {
        targetCustomer: this.mergeField(
          local.context.targetCustomer,
          remote.context.targetCustomer,
          local.updated_at,
          remote.updated_at
        ),
        problemStatement: this.mergeField(
          local.context.problemStatement,
          remote.context.problemStatement,
          local.updated_at,
          remote.updated_at
        ),
        challenges: this.mergeArrays(
          local.context.challenges,
          remote.context.challenges
        ),
        goals: this.mergeArrays(
          local.context.goals,
          remote.context.goals
        )
      }
    };
  }

  private mergeField(
    localValue: any,
    remoteValue: any,
    localTime: string,
    remoteTime: string
  ): any {
    const localT = new Date(localTime).getTime();
    const remoteT = new Date(remoteTime).getTime();

    return remoteT >= localT ? remoteValue : localValue;
  }

  private mergeArrays(local: any[], remote: any[]): any[] {
    // Merge arrays, keeping unique values
    return Array.from(new Set([...local, ...remote]));
  }
}
```

### Sync Status Indicator Component

```tsx
// components/SyncStatus.tsx
import { useSync } from '@/hooks/useSync';
import { CheckCircle, CloudOff, Loader2 } from 'lucide-react';

export function SyncStatus() {
  const { isSyncing, isOnline, lastSyncTime } = useSync();

  if (!isOnline) {
    return (
      <div className="flex items-center gap-2 text-sm text-red-600">
        <CloudOff className="w-4 h-4" />
        <span>Offline</span>
      </div>
    );
  }

  if (isSyncing) {
    return (
      <div className="flex items-center gap-2 text-sm text-blue-600">
        <Loader2 className="w-4 h-4 animate-spin" />
        <span>Syncing...</span>
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2 text-sm text-green-600">
      <CheckCircle className="w-4 h-4" />
      <span>
        Synced {lastSyncTime ? formatRelativeTime(lastSyncTime) : 'now'}
      </span>
    </div>
  );
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create SyncEngine | 90 min |
| Set up Supabase Realtime subscriptions | 45 min |
| Implement offline queue | 45 min |
| Add optimistic updates | 60 min |
| Implement conflict resolution | 45 min |
| Create sync status UI | 30 min |
| Write tests | 45 min |

---

## Acceptance Criteria
- [ ] Real-time sync works across devices
- [ ] Optimistic UI updates instant
- [ ] Offline changes queued and synced when online
- [ ] Conflicts resolved with last-write-wins
- [ ] Sync status displayed to user
- [ ] Works with 10+ concurrent devices
- [ ] Sync latency < 500ms

---

## Performance Considerations

**Delta Sync**: Only sync changed fields, not entire objects

**Throttling**: Batch rapid changes (debounce 500ms)

**Pagination**: For initial sync, fetch in batches of 100 records

**Connection Pooling**: Reuse Supabase connections

**Bandwidth**: Average 5KB per message sync event

---

## Dependencies

```json
{
  "@supabase/supabase-js": "^2.38.0",
  "@supabase/realtime-js": "^2.8.0"
}
```

---

## Database Triggers for Sync

```sql
-- Add updated_at trigger for conflict resolution
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_businesses_updated_at BEFORE UPDATE ON businesses
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_conversations_updated_at BEFORE UPDATE ON conversations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_messages_updated_at BEFORE UPDATE ON messages
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```
