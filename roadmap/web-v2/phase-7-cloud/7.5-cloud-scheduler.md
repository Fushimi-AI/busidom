# Feature 7.5: Cloud Automation Scheduler (Web)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | WEB-7.5 |
| **Phase** | 7 - Cloud Infrastructure (Web) |
| **Priority** | High |
| **Estimated Effort** | 3-4 hours |
| **Dependencies** | WEB-7.1 (Cloud Database), WEB-4.5.3 (Automation Scheduler Core) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement cloud-based cron scheduler using Vercel Cron Jobs or Supabase Edge Functions for executing recurring tasks like daily briefs, weekly reviews, and automated workflows for web/mobile users.

## User Story

As a **web/mobile user**, I want **automated tasks to run reliably in the cloud** so that **I receive daily briefs and weekly reviews without needing my device online**.

---

## Requirements

### Functional
1. Scheduled jobs (cron-based)
2. Per-user job scheduling
3. Email notifications (daily brief, weekly review)
4. Push notifications (mobile)
5. Job execution history
6. Timezone-aware scheduling
7. Job management UI

### Non-Functional
- 99.9% job execution reliability
- Execute within 5 minutes of scheduled time
- Scale to 10K+ users
- Low cost (use serverless)
- Graceful failure handling

---

## Technical Specification

### Architecture Choice: Vercel Cron Jobs

```typescript
// app/api/cron/daily-brief/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

export const dynamic = 'force-dynamic';

export async function GET(req: NextRequest) {
  // Verify cron secret (security)
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // Get all users with daily brief enabled
  const { data: users } = await supabase
    .from('users')
    .select('id, email, timezone, preferences')
    .eq('preferences->daily_brief_enabled', true);

  if (!users) {
    return NextResponse.json({ processed: 0 });
  }

  let processed = 0;

  for (const user of users) {
    try {
      // Check if it's the right time for this user's timezone
      const userLocalTime = getUserLocalTime(user.timezone);
      const scheduledHour = user.preferences.daily_brief_hour || 9; // Default 9 AM

      if (userLocalTime.getHours() === scheduledHour) {
        await sendDailyBrief(user.id, user.email);
        processed++;
      }
    } catch (error) {
      console.error(`Failed to send brief for user ${user.id}:`, error);
    }
  }

  return NextResponse.json({ processed });
}

async function sendDailyBrief(userId: string, email: string) {
  // Generate daily brief
  const brief = await generateDailyBrief(userId);

  // Send via email
  await sendEmail({
    to: email,
    subject: 'Your Daily Business Brief',
    html: formatDailyBriefEmail(brief)
  });

  // Store in database
  await storeBrief(userId, brief);
}

async function generateDailyBrief(userId: string): Promise<string> {
  // Get user's active business
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  const { data: business } = await supabase
    .from('businesses')
    .select('*')
    .eq('user_id', userId)
    .order('updated_at', { ascending: false })
    .limit(1)
    .single();

  if (!business) {
    return 'No active business found.';
  }

  // Generate brief using LLM
  const llm = new OpenAIClient();

  const prompt = `Generate a daily brief for this business:
Name: ${business.name}
Stage: ${business.stage}
Industry: ${business.industry}

Recent activity: [fetch from conversations]

Format:
1. Yesterday's progress
2. Today's priorities
3. Key decision needed
4. One actionable insight`;

  const brief = await llm.chat([{ role: 'user', content: prompt }]);

  return brief.content;
}

function getUserLocalTime(timezone: string): Date {
  return new Date(
    new Date().toLocaleString('en-US', { timeZone: timezone })
  );
}
```

### Vercel Cron Configuration

```json
// vercel.json
{
  "crons": [
    {
      "path": "/api/cron/daily-brief",
      "schedule": "0 * * * *"
    },
    {
      "path": "/api/cron/weekly-review",
      "schedule": "0 18 * * 5"
    },
    {
      "path": "/api/cron/monthly-metrics",
      "schedule": "0 10 1 * *"
    }
  ]
}
```

### Weekly Review Cron

```typescript
// app/api/cron/weekly-review/route.ts
export async function GET(req: NextRequest) {
  const authHeader = req.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  // Get users with weekly review enabled
  const { data: users } = await supabase
    .from('users')
    .select('id, email, timezone, preferences')
    .eq('preferences->weekly_review_enabled', true);

  if (!users) {
    return NextResponse.json({ processed: 0 });
  }

  let processed = 0;

  for (const user of users) {
    try {
      const userLocalTime = getUserLocalTime(user.timezone);

      // Check if it's Friday 6 PM in user's timezone
      if (
        userLocalTime.getDay() === 5 && // Friday
        userLocalTime.getHours() === (user.preferences.weekly_review_hour || 18)
      ) {
        await sendWeeklyReview(user.id, user.email);
        processed++;
      }
    } catch (error) {
      console.error(`Failed to send review for user ${user.id}:`, error);
    }
  }

  return NextResponse.json({ processed });
}

async function sendWeeklyReview(userId: string, email: string) {
  const review = await generateWeeklyReview(userId);

  await sendEmail({
    to: email,
    subject: 'üìä Your Weekly Business Review',
    html: formatWeeklyReviewEmail(review)
  });

  await storeReview(userId, review);
}

async function generateWeeklyReview(userId: string): Promise<string> {
  // Get user's conversations from past week
  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

  const { data: conversations } = await supabase
    .from('conversations')
    .select(`
      id,
      business:businesses(name, stage),
      messages(content, role, created_at)
    `)
    .eq('businesses.user_id', userId)
    .gte('updated_at', oneWeekAgo.toISOString());

  // Use LLM to analyze and generate review
  const llm = new OpenAIClient();

  const prompt = `Analyze this week's business conversations and generate a weekly review:

Conversations: ${JSON.stringify(conversations, null, 2)}

Format:
1. **This Week's Wins**: Key accomplishments
2. **Challenges Faced**: Problems encountered
3. **Decisions Made**: Important decisions
4. **Next Week's Focus**: Top 3 priorities
5. **Metrics Progress**: Any measurable progress
6. **One Reflection**: Key learning or insight`;

  const review = await llm.chat([{ role: 'user', content: prompt }]);

  return review.content;
}
```

### User Preferences Schema

```typescript
// Add to users table
export interface UserPreferences {
  daily_brief_enabled: boolean;
  daily_brief_hour: number; // 0-23
  weekly_review_enabled: boolean;
  weekly_review_hour: number;
  timezone: string; // IANA timezone (e.g., 'America/New_York')
  notification_channels: ('email' | 'push')[];
}
```

### Job Management API

```typescript
// app/api/scheduler/jobs/route.ts
export const GET = withAuth(async (req, userId) => {
  // Get user's scheduled jobs
  const { data: user } = await supabase
    .from('users')
    .select('preferences')
    .eq('id', userId)
    .single();

  const jobs = [
    {
      id: 'daily-brief',
      name: 'Daily Business Brief',
      enabled: user.preferences.daily_brief_enabled,
      schedule: `${user.preferences.daily_brief_hour}:00`,
      timezone: user.preferences.timezone
    },
    {
      id: 'weekly-review',
      name: 'Weekly Progress Review',
      enabled: user.preferences.weekly_review_enabled,
      schedule: `Friday ${user.preferences.weekly_review_hour}:00`,
      timezone: user.preferences.timezone
    }
  ];

  return NextResponse.json({ jobs });
});

export const PATCH = withAuth(async (req, userId) => {
  const { jobId, enabled, hour } = await req.json();

  const updates: any = {};

  if (jobId === 'daily-brief') {
    updates['preferences->daily_brief_enabled'] = enabled;
    if (hour !== undefined) {
      updates['preferences->daily_brief_hour'] = hour;
    }
  } else if (jobId === 'weekly-review') {
    updates['preferences->weekly_review_enabled'] = enabled;
    if (hour !== undefined) {
      updates['preferences->weekly_review_hour'] = hour;
    }
  }

  await supabase
    .from('users')
    .update(updates)
    .eq('id', userId);

  return NextResponse.json({ success: true });
});
```

### Email Service Integration

```typescript
// lib/email.ts
import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY);

export async function sendEmail(options: {
  to: string;
  subject: string;
  html: string;
}) {
  await resend.emails.send({
    from: 'Business-OS <briefs@business-os.dev>',
    to: options.to,
    subject: options.subject,
    html: options.html
  });
}

export function formatDailyBriefEmail(brief: string): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; }
    .content { white-space: pre-wrap; line-height: 1.6; }
    .footer { margin-top: 40px; color: #666; font-size: 12px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìù Your Daily Business Brief</h1>
    <div class="content">${brief}</div>
    <div class="footer">
      Generated by Business-OS | <a href="https://business-os.dev/settings">Manage preferences</a>
    </div>
  </div>
</body>
</html>
  `;
}
```

### Push Notifications (Mobile)

```typescript
// lib/push-notifications.ts
import { Expo } from 'expo-server-sdk';

const expo = new Expo();

export async function sendPushNotification(
  pushToken: string,
  title: string,
  body: string
) {
  if (!Expo.isExpoPushToken(pushToken)) {
    console.error(`Invalid push token: ${pushToken}`);
    return;
  }

  const message = {
    to: pushToken,
    sound: 'default',
    title,
    body,
    data: { type: 'daily-brief' }
  };

  await expo.sendPushNotificationsAsync([message]);
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Set up Vercel Cron Jobs | 30 min |
| Create daily brief endpoint | 60 min |
| Create weekly review endpoint | 45 min |
| Integrate email service (Resend) | 30 min |
| Add push notifications | 30 min |
| Create job management API | 30 min |
| Write tests | 30 min |

---

## Acceptance Criteria
- [ ] Daily briefs sent at user's preferred time
- [ ] Weekly reviews sent every Friday
- [ ] Timezone-aware scheduling
- [ ] Email delivery working
- [ ] Push notifications working (mobile)
- [ ] Users can manage job preferences
- [ ] 99.9% execution reliability

---

## Dependencies

```json
{
  "resend": "^2.0.0",
  "expo-server-sdk": "^3.7.0"
}
```

---

## Environment Variables

```env
CRON_SECRET=your-cron-secret-key
RESEND_API_KEY=re_your_api_key
```

---

## Monitoring

**Track**:
- Job execution count
- Failure rate
- Email delivery rate
- Average generation time

**Use**: Vercel Analytics or Sentry for monitoring
