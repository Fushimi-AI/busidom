# Feature 3.5: Progressive Disclosure

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 3.5 |
| **Phase** | 3 - Intelligence |
| **Priority** | Medium |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 3.3 (Semantic Retrieval) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement a 4-level progressive disclosure system that loads context hierarchically - from summaries to full details - optimizing token usage while maintaining relevance.

## User Story

As a **system**, I need to **load context progressively** so that **token usage is minimized while maintaining quality**.

---

## Requirements

### Functional Requirements
1. 4-level context hierarchy
2. Level 0: Key facts (always loaded)
3. Level 1: Summaries (loaded on relevance)
4. Level 2: Details (loaded on high relevance)
5. Level 3: Full content (loaded on direct query)
6. Automatic level selection

### Non-Functional Requirements
- 50%+ token reduction vs full load
- 70%+ queries answered at Level 0-1
- Level selection < 100ms
- Quality maintained

---

## Technical Specification

### Disclosure Levels

```typescript
// src/core/memory/disclosure-levels.ts

export enum DisclosureLevel {
  KEY_FACTS = 0,    // ~100 tokens - Always loaded
  SUMMARIES = 1,    // ~300 tokens - Often loaded
  DETAILS = 2,      // ~800 tokens - Sometimes loaded
  FULL = 3,         // ~2000 tokens - Rarely loaded
}

export interface LevelContent {
  level: DisclosureLevel;
  content: string;
  tokens: number;
}

export interface DisclosureContext {
  businessId: string;
  levels: LevelContent[];
  currentLevel: DisclosureLevel;
}
```

### Context Summarizer

```typescript
// src/core/memory/context-summarizer.ts
import { ILLMService } from '../interfaces/llm.interface';
import { BusinessContext } from '../../types';

export class ContextSummarizer {
  constructor(private llm: ILLMService) {}

  async generateLevels(context: BusinessContext): Promise<LevelContent[]> {
    const levels: LevelContent[] = [];

    // Level 0: Key Facts (generated)
    const keyFacts = this.extractKeyFacts(context);
    levels.push({
      level: DisclosureLevel.KEY_FACTS,
      content: keyFacts,
      tokens: this.estimateTokens(keyFacts),
    });

    // Level 1: Summaries (LLM generated)
    const summary = await this.generateSummary(context);
    levels.push({
      level: DisclosureLevel.SUMMARIES,
      content: summary,
      tokens: this.estimateTokens(summary),
    });

    // Level 2: Details
    const details = this.formatDetails(context);
    levels.push({
      level: DisclosureLevel.DETAILS,
      content: details,
      tokens: this.estimateTokens(details),
    });

    // Level 3: Full Context
    const full = this.formatFull(context);
    levels.push({
      level: DisclosureLevel.FULL,
      content: full,
      tokens: this.estimateTokens(full),
    });

    return levels;
  }

  private extractKeyFacts(context: BusinessContext): string {
    const facts: string[] = [];

    if (context.businessName) {
      facts.push(`Business: ${context.businessName}`);
    }
    facts.push(`Stage: ${context.stage}`);

    if (context.targetCustomer) {
      facts.push(`Target: ${context.targetCustomer}`);
    }

    if (context.challenges.length > 0) {
      facts.push(`Key challenge: ${context.challenges[0]}`);
    }

    return facts.join(' | ');
  }

  private async generateSummary(context: BusinessContext): Promise<string> {
    const prompt = `Summarize this business context in 2-3 sentences:
${JSON.stringify(context, null, 2)}

Summary:`;

    const result = await this.llm.chat([
      { role: 'user', content: prompt },
    ], { maxTokens: 150, temperature: 0.3 });

    return result.success ? result.data.content : this.extractKeyFacts(context);
  }

  private formatDetails(context: BusinessContext): string {
    let details = '';

    details += `## Business: ${context.businessName || 'Unnamed'}\n`;
    details += `Stage: ${context.stage}\n`;
    details += `Industry: ${context.industry || 'Not specified'}\n\n`;

    if (context.problemStatement) {
      details += `## Problem\n${context.problemStatement}\n\n`;
    }

    if (context.targetCustomer) {
      details += `## Target Customer\n${context.targetCustomer}\n\n`;
    }

    if (context.challenges.length > 0) {
      details += `## Challenges\n${context.challenges.map(c => `- ${c}`).join('\n')}\n\n`;
    }

    if (context.goals.length > 0) {
      details += `## Goals\n${context.goals.map(g => `- ${g}`).join('\n')}\n\n`;
    }

    return details;
  }

  private formatFull(context: BusinessContext): string {
    let full = this.formatDetails(context);

    if (context.milestones && context.milestones.length > 0) {
      full += `## Milestones\n`;
      context.milestones.forEach(m => {
        full += `- [${m.status}] ${m.description}\n`;
      });
      full += '\n';
    }

    if (context.keyDecisions && context.keyDecisions.length > 0) {
      full += `## Key Decisions\n`;
      context.keyDecisions.forEach(d => {
        full += `- ${d.description}`;
        if (d.reasoning) full += ` (${d.reasoning})`;
        full += '\n';
      });
      full += '\n';
    }

    if (context.notes) {
      full += `## Notes\n${context.notes}\n`;
    }

    return full;
  }

  private estimateTokens(text: string): number {
    return Math.ceil(text.length / 4);
  }
}
```

### Level Selector

```typescript
// src/core/memory/level-selector.ts
import { DisclosureLevel, DisclosureContext } from './disclosure-levels';
import { EmbeddingService } from '../../infrastructure/embedding/embedding.service';

export interface LevelSelectionResult {
  level: DisclosureLevel;
  reason: string;
  confidence: number;
}

export class LevelSelector {
  private readonly QUERY_PATTERNS = {
    simple: [
      /what is|what's|tell me about|who is|where is/i,
      /quick|brief|short|summary/i,
    ],
    detailed: [
      /explain|describe|elaborate|detail/i,
      /how does|why did|what are all/i,
    ],
    comprehensive: [
      /everything|complete|full|entire/i,
      /deep dive|thorough|comprehensive/i,
    ],
  };

  constructor(private embeddingService: EmbeddingService) {}

  async selectLevel(
    query: string,
    contextRelevance: number
  ): Promise<LevelSelectionResult> {
    // Pattern-based selection
    const patternLevel = this.selectByPattern(query);
    if (patternLevel !== null) {
      return {
        level: patternLevel,
        reason: 'Query pattern match',
        confidence: 0.9,
      };
    }

    // Relevance-based selection
    if (contextRelevance > 0.9) {
      return {
        level: DisclosureLevel.DETAILS,
        reason: 'High context relevance',
        confidence: contextRelevance,
      };
    }

    if (contextRelevance > 0.7) {
      return {
        level: DisclosureLevel.SUMMARIES,
        reason: 'Moderate context relevance',
        confidence: contextRelevance,
      };
    }

    // Default to key facts
    return {
      level: DisclosureLevel.KEY_FACTS,
      reason: 'Low relevance, using minimal context',
      confidence: 0.8,
    };
  }

  private selectByPattern(query: string): DisclosureLevel | null {
    // Check for comprehensive patterns
    for (const pattern of this.QUERY_PATTERNS.comprehensive) {
      if (pattern.test(query)) {
        return DisclosureLevel.FULL;
      }
    }

    // Check for detailed patterns
    for (const pattern of this.QUERY_PATTERNS.detailed) {
      if (pattern.test(query)) {
        return DisclosureLevel.DETAILS;
      }
    }

    // Check for simple patterns
    for (const pattern of this.QUERY_PATTERNS.simple) {
      if (pattern.test(query)) {
        return DisclosureLevel.KEY_FACTS;
      }
    }

    return null;
  }
}
```

### Progressive Loader

```typescript
// src/core/memory/progressive-loader.ts
import { DisclosureLevel, LevelContent, DisclosureContext } from './disclosure-levels';
import { LevelSelector } from './level-selector';
import { ContextSummarizer } from './context-summarizer';

export class ProgressiveLoader {
  private contextCache: Map<string, DisclosureContext> = new Map();

  constructor(
    private selector: LevelSelector,
    private summarizer: ContextSummarizer
  ) {}

  async loadContext(
    businessId: string,
    context: BusinessContext,
    query: string,
    relevance: number
  ): Promise<{ content: string; level: DisclosureLevel; tokensSaved: number }> {
    // Get or create disclosure context
    let disclosure = this.contextCache.get(businessId);

    if (!disclosure) {
      const levels = await this.summarizer.generateLevels(context);
      disclosure = { businessId, levels, currentLevel: DisclosureLevel.KEY_FACTS };
      this.contextCache.set(businessId, disclosure);
    }

    // Select appropriate level
    const { level } = await this.selector.selectLevel(query, relevance);

    // Get content for selected level (cumulative)
    const content = this.getContentUpToLevel(disclosure.levels, level);
    const fullTokens = disclosure.levels.find(l => l.level === DisclosureLevel.FULL)?.tokens || 0;
    const usedTokens = disclosure.levels
      .filter(l => l.level <= level)
      .reduce((sum, l) => sum + l.tokens, 0);

    return {
      content,
      level,
      tokensSaved: fullTokens - usedTokens,
    };
  }

  private getContentUpToLevel(levels: LevelContent[], maxLevel: DisclosureLevel): string {
    return levels
      .filter(l => l.level <= maxLevel)
      .map(l => l.content)
      .join('\n\n');
  }

  clearCache(businessId?: string): void {
    if (businessId) {
      this.contextCache.delete(businessId);
    } else {
      this.contextCache.clear();
    }
  }

  getStats(): { cached: number; avgTokensSaved: number } {
    return {
      cached: this.contextCache.size,
      avgTokensSaved: 0, // Would track this in production
    };
  }
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 3.5.1 | Define disclosure levels | 20 min |
| 3.5.2 | Create ContextSummarizer | 45 min |
| 3.5.3 | Implement key facts extraction | 20 min |
| 3.5.4 | Implement LLM summarization | 30 min |
| 3.5.5 | Create LevelSelector | 45 min |
| 3.5.6 | Add query pattern matching | 30 min |
| 3.5.7 | Create ProgressiveLoader | 30 min |
| 3.5.8 | Add caching | 20 min |
| 3.5.9 | Track token savings | 20 min |
| 3.5.10 | Write unit tests | 45 min |

---

## Acceptance Criteria

- [ ] 4 disclosure levels implemented
- [ ] Level 0 always under 150 tokens
- [ ] Level selection works correctly
- [ ] 50%+ token reduction achieved
- [ ] 70%+ queries use Level 0-1
- [ ] Caching works
- [ ] Quality maintained
- [ ] Stats tracked

---

## Token Budget by Level

| Level | Target Tokens | Use Case |
|-------|--------------|----------|
| 0 | ~100 | Quick facts, greetings |
| 1 | ~300 | Most queries |
| 2 | ~800 | Deep questions |
| 3 | ~2000 | Full context requests |

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Token savings verified
- [ ] Quality A/B tested

