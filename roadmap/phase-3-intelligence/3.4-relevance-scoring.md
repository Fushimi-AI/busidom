# Feature 3.4: Context Relevance Scoring

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 3.4 |
| **Phase** | 3 - Intelligence |
| **Priority** | High |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 3.3 (Semantic Retrieval) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement sophisticated relevance scoring that combines semantic similarity, recency, source type, and topic alignment to rank retrieved memories more effectively.

## User Story

As a **system**, I need to **score memory relevance accurately** so that **the most pertinent context is prioritized**.

---

## Requirements

### Functional Requirements
1. Multi-factor relevance scoring
2. Recency decay function
3. Source type weighting
4. Topic clustering bonus
5. Configurable scoring weights
6. Score explanation for debugging

### Non-Functional Requirements
- Scoring adds < 50ms overhead
- Transparent scoring factors
- Tunable parameters
- Consistent results

---

## Technical Specification

### Relevance Scorer

```typescript
// src/core/memory/relevance-scorer.ts

export interface ScoringConfig {
  semanticWeight: number;      // 0-1
  recencyWeight: number;       // 0-1
  sourceTypeWeight: number;    // 0-1
  topicBonus: number;          // 0-1
  recencyHalfLife: number;     // days
}

export interface ScoredMemory {
  content: string;
  sourceType: string;
  sourceId: string;
  rawSimilarity: number;
  recencyScore: number;
  sourceScore: number;
  topicScore: number;
  finalScore: number;
  explanation: ScoreExplanation;
}

export interface ScoreExplanation {
  factors: {
    name: string;
    value: number;
    weight: number;
    contribution: number;
  }[];
  totalScore: number;
}

const DEFAULT_CONFIG: ScoringConfig = {
  semanticWeight: 0.5,
  recencyWeight: 0.2,
  sourceTypeWeight: 0.15,
  topicBonus: 0.15,
  recencyHalfLife: 7, // 7 days
};

export class RelevanceScorer {
  private config: ScoringConfig;

  constructor(config: Partial<ScoringConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  score(
    memories: Array<{
      content: string;
      sourceType: string;
      sourceId: string;
      similarity: number;
      createdAt?: Date;
    }>,
    query: string,
    currentTopics?: string[]
  ): ScoredMemory[] {
    const now = new Date();

    return memories.map(memory => {
      // 1. Semantic similarity (already computed)
      const semanticScore = memory.similarity;

      // 2. Recency score
      const recencyScore = this.computeRecencyScore(memory.createdAt, now);

      // 3. Source type score
      const sourceScore = this.computeSourceScore(memory.sourceType);

      // 4. Topic alignment bonus
      const topicScore = currentTopics
        ? this.computeTopicScore(memory.content, currentTopics)
        : 0;

      // Compute weighted final score
      const factors = [
        {
          name: 'semantic',
          value: semanticScore,
          weight: this.config.semanticWeight,
          contribution: semanticScore * this.config.semanticWeight,
        },
        {
          name: 'recency',
          value: recencyScore,
          weight: this.config.recencyWeight,
          contribution: recencyScore * this.config.recencyWeight,
        },
        {
          name: 'sourceType',
          value: sourceScore,
          weight: this.config.sourceTypeWeight,
          contribution: sourceScore * this.config.sourceTypeWeight,
        },
        {
          name: 'topicAlignment',
          value: topicScore,
          weight: this.config.topicBonus,
          contribution: topicScore * this.config.topicBonus,
        },
      ];

      const finalScore = factors.reduce((sum, f) => sum + f.contribution, 0);

      return {
        content: memory.content,
        sourceType: memory.sourceType,
        sourceId: memory.sourceId,
        rawSimilarity: semanticScore,
        recencyScore,
        sourceScore,
        topicScore,
        finalScore,
        explanation: {
          factors,
          totalScore: finalScore,
        },
      };
    }).sort((a, b) => b.finalScore - a.finalScore);
  }

  private computeRecencyScore(createdAt: Date | undefined, now: Date): number {
    if (!createdAt) return 0.5; // Neutral if unknown

    const daysSince = (now.getTime() - createdAt.getTime()) / (1000 * 60 * 60 * 24);

    // Exponential decay with half-life
    return Math.pow(0.5, daysSince / this.config.recencyHalfLife);
  }

  private computeSourceScore(sourceType: string): number {
    const scores: Record<string, number> = {
      context: 1.0,    // Business context is most valuable
      decision: 0.9,   // Key decisions are important
      message: 0.7,    // Regular messages
      document: 0.6,   // External documents
    };

    return scores[sourceType] || 0.5;
  }

  private computeTopicScore(content: string, topics: string[]): number {
    const contentLower = content.toLowerCase();
    let matches = 0;

    for (const topic of topics) {
      if (contentLower.includes(topic.toLowerCase())) {
        matches++;
      }
    }

    return Math.min(matches / topics.length, 1);
  }

  updateConfig(config: Partial<ScoringConfig>): void {
    this.config = { ...this.config, ...config };
  }

  getConfig(): ScoringConfig {
    return { ...this.config };
  }
}
```

### Topic Extractor

```typescript
// src/core/memory/topic-extractor.ts

export class TopicExtractor {
  private readonly STOP_WORDS = new Set([
    'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been',
    'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will',
    'would', 'could', 'should', 'may', 'might', 'must', 'shall',
    'can', 'need', 'dare', 'ought', 'used', 'to', 'of', 'in',
    'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into',
    'through', 'during', 'before', 'after', 'above', 'below',
    'between', 'under', 'again', 'further', 'then', 'once',
    'here', 'there', 'when', 'where', 'why', 'how', 'all',
    'each', 'few', 'more', 'most', 'other', 'some', 'such',
    'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than',
    'too', 'very', 'just', 'and', 'but', 'if', 'or', 'because',
    'until', 'while', 'what', 'which', 'who', 'whom', 'this',
    'that', 'these', 'those', 'am', 'it', 'its', 'i', 'you',
    'he', 'she', 'we', 'they', 'my', 'your', 'his', 'her',
    'our', 'their', 'me', 'him', 'us', 'them',
  ]);

  extract(text: string, maxTopics: number = 5): string[] {
    // Tokenize and clean
    const words = text
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, ' ')
      .split(/\s+/)
      .filter(w => w.length > 3)
      .filter(w => !this.STOP_WORDS.has(w));

    // Count frequency
    const frequency = new Map<string, number>();
    for (const word of words) {
      frequency.set(word, (frequency.get(word) || 0) + 1);
    }

    // Sort by frequency
    const sorted = [...frequency.entries()]
      .sort((a, b) => b[1] - a[1])
      .slice(0, maxTopics)
      .map(([word]) => word);

    return sorted;
  }

  extractFromMessages(messages: Array<{ content: string }>): string[] {
    const combined = messages.map(m => m.content).join(' ');
    return this.extract(combined, 10);
  }
}
```

### Enhanced Retriever

```typescript
// src/core/memory/enhanced-retriever.ts
import { MemoryRetriever } from './memory-retriever';
import { RelevanceScorer, ScoredMemory } from './relevance-scorer';
import { TopicExtractor } from './topic-extractor';

export class EnhancedMemoryRetriever {
  constructor(
    private baseRetriever: MemoryRetriever,
    private scorer: RelevanceScorer,
    private topicExtractor: TopicExtractor
  ) {}

  async retrieve(
    query: string,
    recentMessages: Array<{ content: string }>,
    options?: { limit?: number; debug?: boolean }
  ): Promise<ScoredMemory[]> {
    const { limit = 10, debug = false } = options || {};

    // Get raw results
    const rawResults = await this.baseRetriever.retrieve(query, {
      limit: limit * 2,
      threshold: 0.5, // Lower threshold, let scorer filter
    });

    // Extract current topics
    const topics = this.topicExtractor.extractFromMessages(recentMessages);

    // Score results
    const scored = this.scorer.score(
      rawResults.map(r => ({
        content: r.content,
        sourceType: r.sourceType,
        sourceId: '', // Would need to add this
        similarity: r.similarity,
      })),
      query,
      topics
    );

    if (debug) {
      this.logScoringDebug(scored.slice(0, 5));
    }

    return scored.slice(0, limit);
  }

  private logScoringDebug(memories: ScoredMemory[]): void {
    console.log('\n--- Relevance Scoring Debug ---');
    memories.forEach((m, i) => {
      console.log(`\n${i + 1}. "${m.content.slice(0, 50)}..."`);
      console.log(`   Final Score: ${m.finalScore.toFixed(3)}`);
      m.explanation.factors.forEach(f => {
        console.log(`   - ${f.name}: ${f.value.toFixed(3)} Ã— ${f.weight} = ${f.contribution.toFixed(3)}`);
      });
    });
    console.log('\n--- End Debug ---\n');
  }
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 3.4.1 | Create RelevanceScorer class | 45 min |
| 3.4.2 | Implement recency decay | 30 min |
| 3.4.3 | Implement source weighting | 20 min |
| 3.4.4 | Create TopicExtractor | 30 min |
| 3.4.5 | Implement topic scoring | 30 min |
| 3.4.6 | Add score explanation | 20 min |
| 3.4.7 | Create EnhancedRetriever | 30 min |
| 3.4.8 | Add debug mode | 15 min |
| 3.4.9 | Make weights configurable | 20 min |
| 3.4.10 | Write unit tests | 45 min |

---

## Acceptance Criteria

- [ ] Multi-factor scoring works
- [ ] Recency decay applied
- [ ] Source types weighted correctly
- [ ] Topic alignment improves results
- [ ] Weights are configurable
- [ ] Debug shows explanation
- [ ] Scoring < 50ms overhead
- [ ] Results more relevant

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] A/B tested against basic retrieval
- [ ] Unit tests passing

