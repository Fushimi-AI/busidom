# Feature 1.5: Session Memory (JSON)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 1.5 |
| **Phase** | 1 - MVP Core |
| **Priority** | Critical |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 0.5 (Configuration), 1.1 (Chat Interface) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement persistent conversation memory using JSON files for the MVP. Conversations are saved automatically and loaded on startup, allowing the AI to maintain context across sessions.

## User Story

As a **founder**, I want my **conversations saved automatically** so that **the AI remembers our previous discussions**.

---

## Requirements

### Functional Requirements
1. Auto-save conversation after each message
2. Load last conversation on startup
3. Support multiple conversations
4. /save command to explicitly save
5. /load <id> command to load conversation
6. /history command to list conversations
7. /new command to start fresh conversation

### Non-Functional Requirements
- Save completes in < 100ms
- Handle corrupted files gracefully
- No data loss on crash
- Support conversations up to 100 messages

---

## Technical Specification

### Storage Structure

```
~/.bos/
â”œâ”€â”€ config.json          # User configuration
â”œâ”€â”€ context.json         # Business context
â””â”€â”€ conversations/
    â”œâ”€â”€ index.json       # Conversation list
    â”œâ”€â”€ conv_abc123.json # Individual conversation
    â””â”€â”€ conv_def456.json
```

### Conversation Schema

```typescript
// src/types/conversation.ts
export interface StoredConversation {
  id: string;
  title: string;        // Auto-generated from first message
  businessId: string | null;
  messages: StoredMessage[];
  createdAt: string;    // ISO date
  updatedAt: string;
  messageCount: number;
}

export interface StoredMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: string;
}

export interface ConversationIndex {
  conversations: ConversationSummary[];
  activeId: string | null;
}

export interface ConversationSummary {
  id: string;
  title: string;
  updatedAt: string;
  messageCount: number;
}
```

### JSON Storage Service

```typescript
// src/infrastructure/storage/json-storage.service.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { StoredConversation, ConversationIndex } from '../../types';

export class JSONStorageService implements IStorageService {
  private basePath: string;

  constructor(basePath: string = '~/.bos') {
    this.basePath = basePath.replace('~', process.env.HOME || '');
  }

  async init(): Promise<void> {
    const convPath = path.join(this.basePath, 'conversations');
    await fs.mkdir(convPath, { recursive: true });

    // Create index if not exists
    const indexPath = path.join(convPath, 'index.json');
    if (!await this.exists(indexPath)) {
      await this.writeJSON(indexPath, {
        conversations: [],
        activeId: null,
      });
    }
  }

  async saveConversation(conv: StoredConversation): Promise<void> {
    const filePath = this.getConversationPath(conv.id);
    await this.writeJSON(filePath, conv);
    await this.updateIndex(conv);
  }

  async loadConversation(id: string): Promise<StoredConversation | null> {
    const filePath = this.getConversationPath(id);

    if (!await this.exists(filePath)) {
      return null;
    }

    try {
      return await this.readJSON<StoredConversation>(filePath);
    } catch (error) {
      console.warn(`Failed to load conversation ${id}:`, error);
      return null;
    }
  }

  async loadActiveConversation(): Promise<StoredConversation | null> {
    const index = await this.getIndex();

    if (!index.activeId) {
      return null;
    }

    return this.loadConversation(index.activeId);
  }

  async listConversations(): Promise<ConversationSummary[]> {
    const index = await this.getIndex();
    return index.conversations.sort(
      (a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
    );
  }

  async setActiveConversation(id: string): Promise<void> {
    const index = await this.getIndex();
    index.activeId = id;
    await this.writeJSON(this.getIndexPath(), index);
  }

  async deleteConversation(id: string): Promise<void> {
    const filePath = this.getConversationPath(id);
    await fs.unlink(filePath).catch(() => {});

    const index = await this.getIndex();
    index.conversations = index.conversations.filter(c => c.id !== id);
    if (index.activeId === id) {
      index.activeId = null;
    }
    await this.writeJSON(this.getIndexPath(), index);
  }

  // Helper methods
  private getConversationPath(id: string): string {
    return path.join(this.basePath, 'conversations', `conv_${id}.json`);
  }

  private getIndexPath(): string {
    return path.join(this.basePath, 'conversations', 'index.json');
  }

  private async getIndex(): Promise<ConversationIndex> {
    return this.readJSON<ConversationIndex>(this.getIndexPath());
  }

  private async updateIndex(conv: StoredConversation): Promise<void> {
    const index = await this.getIndex();

    const existing = index.conversations.findIndex(c => c.id === conv.id);
    const summary: ConversationSummary = {
      id: conv.id,
      title: conv.title,
      updatedAt: conv.updatedAt,
      messageCount: conv.messageCount,
    };

    if (existing >= 0) {
      index.conversations[existing] = summary;
    } else {
      index.conversations.unshift(summary);
    }

    index.activeId = conv.id;
    await this.writeJSON(this.getIndexPath(), index);
  }

  private async readJSON<T>(filePath: string): Promise<T> {
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content);
  }

  private async writeJSON(filePath: string, data: unknown): Promise<void> {
    const content = JSON.stringify(data, null, 2);
    await fs.writeFile(filePath, content, 'utf-8');
  }

  private async exists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
```

### Memory Service

```typescript
// src/core/memory/memory.service.ts
import { IStorageService } from '../interfaces/storage.interface';
import { Message, StoredConversation } from '../../types';
import { generateId } from '../../utils';

export class MemoryService {
  private currentConversation: StoredConversation | null = null;
  private autoSaveEnabled: boolean = true;

  constructor(private storage: IStorageService) {}

  async init(): Promise<void> {
    await this.storage.init();
    this.currentConversation = await this.storage.loadActiveConversation();
  }

  async addMessage(message: Message): Promise<void> {
    if (!this.currentConversation) {
      await this.startNewConversation();
    }

    this.currentConversation!.messages.push({
      id: message.id,
      role: message.role,
      content: message.content,
      timestamp: message.timestamp.toISOString(),
    });

    this.currentConversation!.updatedAt = new Date().toISOString();
    this.currentConversation!.messageCount = this.currentConversation!.messages.length;

    // Auto-generate title from first user message
    if (!this.currentConversation!.title && message.role === 'user') {
      this.currentConversation!.title = this.generateTitle(message.content);
    }

    if (this.autoSaveEnabled) {
      await this.save();
    }
  }

  async startNewConversation(): Promise<void> {
    this.currentConversation = {
      id: generateId(),
      title: '',
      businessId: null,
      messages: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      messageCount: 0,
    };
    await this.save();
  }

  async loadConversation(id: string): Promise<boolean> {
    const conv = await this.storage.loadConversation(id);
    if (conv) {
      this.currentConversation = conv;
      await this.storage.setActiveConversation(id);
      return true;
    }
    return false;
  }

  async save(): Promise<void> {
    if (this.currentConversation) {
      await this.storage.saveConversation(this.currentConversation);
    }
  }

  getMessages(): Message[] {
    if (!this.currentConversation) return [];

    return this.currentConversation.messages.map(m => ({
      id: m.id,
      role: m.role,
      content: m.content,
      timestamp: new Date(m.timestamp),
    }));
  }

  clear(): void {
    if (this.currentConversation) {
      this.currentConversation.messages = [];
      this.currentConversation.messageCount = 0;
    }
  }

  private generateTitle(content: string): string {
    // First 50 chars of first message
    return content.slice(0, 50) + (content.length > 50 ? '...' : '');
  }
}
```

### CLI Commands

```typescript
// src/cli/commands/memory.commands.ts
export function registerMemoryCommands(repl: REPL, memory: MemoryService): void {
  repl.registerCommand('/save', async () => {
    await memory.save();
    console.log(chalk.green('âœ“ Conversation saved'));
  });

  repl.registerCommand('/new', async () => {
    await memory.startNewConversation();
    console.log(chalk.green('âœ“ Started new conversation'));
  });

  repl.registerCommand('/history', async () => {
    const conversations = await memory.listConversations();

    if (conversations.length === 0) {
      console.log(chalk.yellow('No conversations yet'));
      return;
    }

    console.log(chalk.bold('\nðŸ“œ Conversation History\n'));
    conversations.slice(0, 10).forEach((c, i) => {
      console.log(`  ${i + 1}. ${c.title || 'Untitled'}`);
      console.log(chalk.gray(`     ${c.messageCount} messages â€¢ ${formatDate(c.updatedAt)}`));
      console.log(chalk.gray(`     ID: ${c.id}`));
    });
    console.log();
  });

  repl.registerCommand('/load', async (args: string) => {
    const id = args.trim();
    if (!id) {
      console.log(chalk.yellow('Usage: /load <conversation-id>'));
      return;
    }

    const loaded = await memory.loadConversation(id);
    if (loaded) {
      console.log(chalk.green(`âœ“ Loaded conversation`));
    } else {
      console.log(chalk.red(`Conversation not found: ${id}`));
    }
  });
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 1.5.1 | Define storage types | 20 min |
| 1.5.2 | Implement JSONStorageService | 60 min |
| 1.5.3 | Implement MemoryService | 45 min |
| 1.5.4 | Add auto-save after messages | 20 min |
| 1.5.5 | Load active conversation on startup | 20 min |
| 1.5.6 | Implement /save command | 15 min |
| 1.5.7 | Implement /new command | 15 min |
| 1.5.8 | Implement /history command | 20 min |
| 1.5.9 | Implement /load command | 20 min |
| 1.5.10 | Write unit tests | 45 min |
| 1.5.11 | Handle corrupted files | 20 min |

---

## Acceptance Criteria

- [ ] Conversations auto-save after each message
- [ ] Last conversation loads on startup
- [ ] /save explicitly saves
- [ ] /new starts fresh conversation
- [ ] /history lists recent conversations
- [ ] /load <id> loads specific conversation
- [ ] Corrupted files handled gracefully
- [ ] Works with 100+ messages

---

## File Structure

```
src/
â”œâ”€â”€ types/
â”‚   â””â”€â”€ conversation.ts
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â””â”€â”€ storage.interface.ts
â”‚   â””â”€â”€ memory/
â”‚       â”œâ”€â”€ index.ts
â”‚       â””â”€â”€ memory.service.ts
â”œâ”€â”€ infrastructure/
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ index.ts
â”‚       â””â”€â”€ json-storage.service.ts
â””â”€â”€ cli/
    â””â”€â”€ commands/
        â””â”€â”€ memory.commands.ts
```

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Data corruption | High | Atomic writes, backups |
| Large files | Medium | Limit message count |
| Concurrent access | Low | Single process for MVP |

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Auto-save verified
- [ ] Load on startup verified
- [ ] Commands tested

