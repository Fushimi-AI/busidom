# Feature 1.4: Context Extraction

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 1.4 |
| **Phase** | 1 - MVP Core |
| **Priority** | High |
| **Estimated Effort** | 5-6 hours |
| **Dependencies** | 1.1 (Chat Interface), 1.2 (LLM Integration) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Automatically extract and maintain business context from conversations including business name, stage, challenges, goals, and key decisions. This context persists across sessions.

## User Story

As a **founder**, I want the **AI to remember my business details** so that **I don't have to repeat context every conversation**.

---

## Requirements

### Functional Requirements
1. Extract business name from conversation
2. Detect business stage (idea/mvp/growth/scale)
3. Identify key challenges mentioned
4. Track goals and milestones
5. Note important decisions made
6. Update context as conversation progresses
7. /context command to view extracted info

### Non-Functional Requirements
- Extraction runs in background (not blocking)
- Context updates incrementally
- Graceful handling of ambiguous info
- User can correct extracted info

---

## Technical Specification

### Context Schema

```typescript
// src/types/context.ts
export interface BusinessContext {
  // Core info
  businessId: string;
  businessName: string | null;
  industry: string | null;
  stage: BusinessStage;

  // Target market
  targetCustomer: string | null;
  problemStatement: string | null;

  // Progress
  challenges: string[];
  goals: string[];
  milestones: Milestone[];

  // Decisions
  keyDecisions: Decision[];

  // Meta
  extractedAt: Date;
  confidence: number; // 0-1
}

export interface Milestone {
  description: string;
  status: 'planned' | 'in_progress' | 'completed';
  mentionedAt: Date;
}

export interface Decision {
  description: string;
  reasoning: string | null;
  madeAt: Date;
}

export enum BusinessStage {
  IDEA = 'idea',
  MVP = 'mvp',
  GROWTH = 'growth',
  SCALE = 'scale',
}
```

### Context Extractor

```typescript
// src/core/context/extractor.ts
import { ILLMService } from '../interfaces/llm.interface';
import { Message, BusinessContext } from '../../types';

const EXTRACTION_PROMPT = `Analyze the conversation and extract business information.

Return a JSON object with:
{
  "businessName": string or null,
  "industry": string or null,
  "stage": "idea" | "mvp" | "growth" | "scale",
  "targetCustomer": string or null,
  "problemStatement": string or null,
  "challenges": string[],
  "goals": string[],
  "keyDecisions": [{ "description": string, "reasoning": string }],
  "confidence": number (0-1)
}

Rules:
- Only extract what is explicitly stated
- Set null if information is not mentioned
- Stage detection:
  - "idea": No product yet, exploring
  - "mvp": Building/launched initial product
  - "growth": Has customers, scaling
  - "scale": Established, optimizing
- Be conservative with confidence score

Conversation:
`;

export class ContextExtractor {
  constructor(private llm: ILLMService) {}

  async extract(messages: Message[]): Promise<BusinessContext> {
    const conversationText = messages
      .filter(m => m.role !== 'system')
      .map(m => `${m.role}: ${m.content}`)
      .join('\n');

    const result = await this.llm.chat([
      { role: 'system', content: EXTRACTION_PROMPT },
      { role: 'user', content: conversationText },
    ], {
      temperature: 0.1, // Low temp for consistent extraction
      maxTokens: 1000,
    });

    if (!result.success) {
      throw result.error;
    }

    return this.parseExtraction(result.data.content);
  }

  private parseExtraction(content: string): BusinessContext {
    // Extract JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Failed to extract context');
    }

    const extracted = JSON.parse(jsonMatch[0]);

    return {
      businessId: generateId(),
      businessName: extracted.businessName,
      industry: extracted.industry,
      stage: extracted.stage || BusinessStage.IDEA,
      targetCustomer: extracted.targetCustomer,
      problemStatement: extracted.problemStatement,
      challenges: extracted.challenges || [],
      goals: extracted.goals || [],
      milestones: [],
      keyDecisions: (extracted.keyDecisions || []).map((d: any) => ({
        description: d.description,
        reasoning: d.reasoning,
        madeAt: new Date(),
      })),
      extractedAt: new Date(),
      confidence: extracted.confidence || 0.5,
    };
  }
}
```

### Context Service

```typescript
// src/core/context/context.service.ts
export class ContextService {
  private context: BusinessContext | null = null;
  private extractor: ContextExtractor;
  private storage: IStorageService;

  constructor(llm: ILLMService, storage: IStorageService) {
    this.extractor = new ContextExtractor(llm);
    this.storage = storage;
  }

  async updateFromMessages(messages: Message[]): Promise<void> {
    // Only extract if we have enough context
    if (messages.length < 3) return;

    try {
      const newContext = await this.extractor.extract(messages);

      if (this.context) {
        // Merge with existing context
        this.context = this.mergeContexts(this.context, newContext);
      } else {
        this.context = newContext;
      }

      await this.save();
    } catch (error) {
      console.warn('Context extraction failed:', error);
      // Non-blocking - continue without updated context
    }
  }

  private mergeContexts(
    existing: BusinessContext,
    extracted: BusinessContext
  ): BusinessContext {
    return {
      ...existing,
      // Update if extracted with higher confidence
      businessName: extracted.businessName || existing.businessName,
      industry: extracted.industry || existing.industry,
      stage: extracted.confidence > 0.7 ? extracted.stage : existing.stage,
      targetCustomer: extracted.targetCustomer || existing.targetCustomer,
      problemStatement: extracted.problemStatement || existing.problemStatement,
      // Append arrays (deduplicate)
      challenges: [...new Set([...existing.challenges, ...extracted.challenges])],
      goals: [...new Set([...existing.goals, ...extracted.goals])],
      keyDecisions: [...existing.keyDecisions, ...extracted.keyDecisions],
      // Update meta
      extractedAt: new Date(),
      confidence: Math.max(existing.confidence, extracted.confidence),
    };
  }

  getContext(): BusinessContext | null {
    return this.context;
  }

  async save(): Promise<void> {
    if (this.context) {
      await this.storage.save('context', this.context);
    }
  }

  async load(): Promise<void> {
    this.context = await this.storage.load('context');
  }

  // Manual update by user
  update(partial: Partial<BusinessContext>): void {
    if (this.context) {
      this.context = { ...this.context, ...partial };
    }
  }
}
```

### Context Display

```typescript
// src/cli/commands/context.command.ts
import chalk from 'chalk';
import { BusinessContext } from '../../types';

export function displayContext(context: BusinessContext | null): void {
  if (!context) {
    console.log(chalk.yellow('No business context yet. Start chatting!'));
    return;
  }

  console.log(chalk.bold('\nðŸ“Š Business Context\n'));

  console.log(chalk.cyan('Business:'), context.businessName || 'Not identified');
  console.log(chalk.cyan('Industry:'), context.industry || 'Not identified');
  console.log(chalk.cyan('Stage:'), formatStage(context.stage));
  console.log(chalk.cyan('Target:'), context.targetCustomer || 'Not identified');

  if (context.challenges.length > 0) {
    console.log(chalk.cyan('\nChallenges:'));
    context.challenges.forEach(c => console.log(`  â€¢ ${c}`));
  }

  if (context.goals.length > 0) {
    console.log(chalk.cyan('\nGoals:'));
    context.goals.forEach(g => console.log(`  â€¢ ${g}`));
  }

  console.log(chalk.gray(`\nConfidence: ${(context.confidence * 100).toFixed(0)}%`));
  console.log(chalk.gray(`Last updated: ${context.extractedAt.toLocaleString()}`));
  console.log();
}

function formatStage(stage: BusinessStage): string {
  const icons = { idea: 'ðŸ’¡', mvp: 'ðŸ”¨', growth: 'ðŸ“ˆ', scale: 'ðŸš€' };
  return `${icons[stage]} ${stage.toUpperCase()}`;
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 1.4.1 | Define context types | 20 min |
| 1.4.2 | Create extraction prompt | 45 min |
| 1.4.3 | Implement ContextExtractor | 45 min |
| 1.4.4 | Implement ContextService | 45 min |
| 1.4.5 | Add context merging logic | 30 min |
| 1.4.6 | Implement /context command | 30 min |
| 1.4.7 | Add context persistence | 30 min |
| 1.4.8 | Background extraction (non-blocking) | 30 min |
| 1.4.9 | Write unit tests | 45 min |
| 1.4.10 | Test with real conversations | 30 min |

---

## Acceptance Criteria

- [ ] Business name extracted correctly
- [ ] Stage detected accurately
- [ ] Challenges captured
- [ ] Goals captured
- [ ] /context shows current context
- [ ] Context persists across sessions
- [ ] Context updates incrementally
- [ ] Extraction doesn't block chat
- [ ] Low confidence = conservative extraction

---

## File Structure

```
src/
â”œâ”€â”€ types/
â”‚   â””â”€â”€ context.ts
â”œâ”€â”€ core/
â”‚   â””â”€â”€ context/
â”‚       â”œâ”€â”€ index.ts
â”‚       â”œâ”€â”€ extractor.ts
â”‚       â””â”€â”€ context.service.ts
â”œâ”€â”€ cli/
â”‚   â””â”€â”€ commands/
â”‚       â””â”€â”€ context.command.ts
```

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Incorrect extraction | Medium | Low confidence = no update |
| LLM costs | Low | Extract every N messages |
| Slow extraction | Low | Background/async |

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Extraction accuracy > 80%
- [ ] Non-blocking extraction
- [ ] Persists correctly

