# Feature 4.5.4: Event-Driven Triggers

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 4.5.4 |
| **Phase** | 4.5 - Automation & Workflows |
| **Priority** | High |
| **Estimated Effort** | 5-6 hours |
| **Dependencies** | 4.5.1 (Workflow Engine), 4.5.3 (Scheduler), 5.6 (Proactive Accountability), 5.7 (Monitoring Engine) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Event-driven system that triggers workflows and automations based on business events, milestones, state changes, **and commitment tracking** rather than time-based schedules.

**Enhanced with Proactive Accountability**: Event system now includes commitment lifecycle events - creation, follow-ups, completion, and abandonment.

## Requirements

### Functional
1. Event bus (pub/sub)
2. Event definitions
3. Trigger conditions
4. Action execution
5. Event history

### Non-Functional
- Real-time event processing
- At-least-once delivery
- Idempotent actions
- Scalable event handling

---

## Event Catalog

### Business Events

**Stage Progression**
```yaml
event: business.stage_changed
payload:
  businessId: uuid
  oldStage: idea
  newStage: mvp
  timestamp: datetime

triggers:
  - workflow: mvp_scoping_workflow
  - automation: daily_build_progress
  - notification: "Congrats on reaching MVP stage!"
```

**Goal Completed**
```yaml
event: goal.completed
payload:
  businessId: uuid
  goalId: uuid
  goal: "Conduct 5 customer interviews"
  completedAt: datetime

triggers:
  - agent: mentor
    prompt: "Celebrate goal completion and suggest next step"
  - check: stage_progression_eligibility
```

**Milestone Reached**
```yaml
event: milestone.reached
payload:
  businessId: uuid
  milestone: first_paying_customer
  value: "$50 MRR"

triggers:
  - workflow: unit_economics_validation
  - notification: "üéâ First paying customer! Let's validate economics."
  - agent: mentor
    prompt: "Analyze what led to first customer success"
```

---

### Metric Events

**Revenue Threshold**
```yaml
event: metrics.revenue_threshold
payload:
  businessId: uuid
  metric: mrr
  value: 10000
  threshold: 10000

triggers:
  - notification: "$10K MRR reached!"
  - agent: mentor
    prompt: "Analyze growth trajectory and recommend scaling strategies"
  - workflow: fundraising_preparation  # If appropriate
```

**User Count Milestone**
```yaml
event: metrics.user_milestone
payload:
  businessId: uuid
  users: 1000
  milestone: 1000

triggers:
  - agent: research
    prompt: "Analyze user cohorts and identify expansion opportunities"
```

**Churn Alert**
```yaml
event: metrics.churn_spike
payload:
  businessId: uuid
  churnRate: 15  # %
  normalRate: 5
  increase: 200  # %

triggers:
  - alert: "‚ö†Ô∏è Churn spike detected!"
  - agent: mentor
    prompt: "Investigate churn causes and recommend interventions"
  - workflow: customer_retention_audit
```

---

### Activity Events

**No Progress (3 days)**
```yaml
event: activity.stalled
payload:
  businessId: uuid
  daysSinceLastActivity: 3

triggers:
  - notification: "You've been quiet. Need help?"
  - agent: mentor
    prompt: "Check in and identify blockers"
```

**Rapid Progress**
```yaml
event: activity.momentum
payload:
  businessId: uuid
  tasksCompleted: 10
  timeframe: "3 days"

triggers:
  - notification: "üî• You're on fire! Keep it up!"
  - agent: mentor
    prompt: "Acknowledge momentum and guide next steps"
```

**Decision Pending (7 days)**
```yaml
event: workflow.decision_overdue
payload:
  workflowId: uuid
  stepId: "final_decision"
  daysPending: 7

triggers:
  - reminder: "Decision pending: Should you continue with this idea?"
  - agent: mentor
    prompt: "Help make the decision based on data collected"
```

---

### Integration Events

**Customer Feedback Received**
```yaml
event: feedback.received
payload:
  businessId: uuid
  source: "email" | "survey" | "call"
  sentiment: "positive" | "negative" | "neutral"
  text: string

triggers:
  - store: Add to context
  - agent: research
    prompt: "Analyze feedback themes and suggest improvements"
```

**Competitor Launched**
```yaml
event: market.competitor_activity
payload:
  businessId: uuid
  competitor: string
  activity: "product_launch" | "funding" | "acquisition"

triggers:
  - notification: "Competitor update: [activity]"
  - agent: research
    prompt: "Analyze competitive threat and recommend response"
```

---

### Commitment Events (Proactive Accountability Integration)

**Commitment Created**
```yaml
event: commitment.created
payload:
  businessId: uuid
  commitmentId: uuid
  userId: uuid
  text: "I'll talk to 10 customers this week"
  parsedGoal: "Talk to 10 customers"
  deadline: datetime
  category: customer_validation
  confidence: 0.9

triggers:
  - scheduler: schedule_followups  # Schedule follow-up check-ins
  - notification: "Commitment tracked: ${parsedGoal}"
  - agent: mentor
    prompt: "Acknowledge commitment and offer support"
```

**Follow-Up Due**
```yaml
event: commitment.followup_due
payload:
  businessId: uuid
  commitmentId: uuid
  followUpId: uuid
  commitment: "Talk to 10 customers"
  deadline: datetime
  type: early_check | deadline | overdue

triggers:
  - notification: "Check-in: ${commitment}"
  - agent: accountability
    prompt: "Send contextual check-in message and ask for progress"
  - workflow: commitment_progress_check
```

**Commitment Completed**
```yaml
event: commitment.completed
payload:
  businessId: uuid
  commitmentId: uuid
  commitment: "Talk to 10 customers"
  completedAt: datetime
  evidence: "Talked to 12 customers"

triggers:
  - notification: "‚úÖ Commitment completed!"
  - agent: mentor
    prompt: "Celebrate completion and suggest next steps based on learnings"
  - scheduler: cancel_pending_followups  # Cancel remaining follow-ups
  - check: update_accountability_score
```

**Commitment Overdue**
```yaml
event: commitment.overdue
payload:
  businessId: uuid
  commitmentId: uuid
  commitment: "Talk to 10 customers"
  deadline: datetime
  daysOverdue: 2

triggers:
  - notification: "‚ö†Ô∏è Commitment overdue: ${commitment}"
  - agent: accountability
    prompt: "Check in with empathy, identify blockers, offer to help or reschedule"
```

**Commitment Abandoned**
```yaml
event: commitment.abandoned
payload:
  businessId: uuid
  commitmentId: uuid
  commitment: "Talk to 10 customers"
  reason: "user_marked" | "too_many_followups" | "stale"

triggers:
  - agent: mentor
    prompt: "Understand why abandoned, identify patterns, offer support"
  - check: accountability_score_impact
```

**Commitment Pattern Detected**
```yaml
event: commitment.pattern_detected
payload:
  businessId: uuid
  userId: uuid
  pattern: "consistently_overdue" | "high_completion_rate" | "avoiding_category"
  category?: customer_validation | product | hiring
  count: 5
  timeframe: "30 days"

triggers:
  - agent: mentor
    prompt: "Address pattern (celebrate success or identify blockers)"
  - workflow: accountability_coaching
```

---

### Monitoring Events (Always-On Monitoring Integration)

**Monitor Alert**
```yaml
event: monitor.alert
payload:
  businessId: uuid
  monitorId: uuid
  monitorName: "Track competitor pricing"
  changeSummary: "Competitor dropped pricing by 20%"
  changeScore: 0.8
  currentData: object
  previousData: object

triggers:
  - notification: "üîî ${monitorName}: ${changeSummary}"
  - agent: research
    prompt: "Analyze change impact and recommend actions"
  - check: requires_immediate_action
```

**Monitor Failed**
```yaml
event: monitor.failed
payload:
  businessId: uuid
  monitorId: uuid
  monitorName: "API health check"
  error: string
  consecutiveFailures: 3

triggers:
  - notification: "‚ö†Ô∏è Monitor failing: ${monitorName}"
  - check: disable_if_persistent
```

---

## Technical Implementation

```typescript
// src/core/events/event-bus.ts
import { EventEmitter } from 'events';

export interface BusinessEvent {
  type: string;
  payload: Record<string, unknown>;
  timestamp: Date;
  businessId: string;
}

export interface EventTrigger {
  event: string;
  condition?: (payload: unknown) => boolean;
  actions: TriggerAction[];
}

export interface TriggerAction {
  type: 'workflow' | 'automation' | 'agent' | 'notification';
  target: string;
  config?: Record<string, unknown>;
}

export class EventBus extends EventEmitter {
  private triggers: Map<string, EventTrigger[]> = new Map();

  constructor(
    private workflowEngine: WorkflowEngine,
    private automationScheduler: AutomationScheduler,
    private agentRegistry: AgentRegistry,
    private notificationService: NotificationService
  ) {
    super();
    this.setMaxListeners(100);
  }

  registerTrigger(trigger: EventTrigger): void {
    const triggers = this.triggers.get(trigger.event) || [];
    triggers.push(trigger);
    this.triggers.set(trigger.event, triggers);

    // Set up listener
    this.on(trigger.event, async (event: BusinessEvent) => {
      await this.handleEvent(event, trigger);
    });
  }

  async publish(event: BusinessEvent): Promise<void> {
    this.emit(event.type, event);

    // Store event history
    await this.eventRepo.store(event);
  }

  private async handleEvent(
    event: BusinessEvent,
    trigger: EventTrigger
  ): Promise<void> {
    // Check condition
    if (trigger.condition && !trigger.condition(event.payload)) {
      return;
    }

    // Execute actions
    for (const action of trigger.actions) {
      try {
        await this.executeAction(action, event);
      } catch (error) {
        console.error(`Failed to execute action:`, error);
      }
    }
  }

  private async executeAction(
    action: TriggerAction,
    event: BusinessEvent
  ): Promise<void> {
    switch (action.type) {
      case 'workflow':
        await this.workflowEngine.startWorkflow(
          action.target,
          event.businessId
        );
        break;

      case 'agent':
        const agent = this.agentRegistry.get(action.target);
        const prompt = action.config?.prompt as string;
        await agent.execute(prompt);
        break;

      case 'notification':
        await this.notificationService.send(
          event.businessId,
          action.target
        );
        break;

      case 'automation':
        await this.automationScheduler.triggerNow(
          action.target,
          event.businessId
        );
        break;
    }
  }
}

// Usage
eventBus.registerTrigger({
  event: 'business.stage_changed',
  condition: (payload: any) => payload.newStage === 'mvp',
  actions: [
    {
      type: 'workflow',
      target: 'mvp_scoping_workflow',
    },
    {
      type: 'notification',
      target: 'Congrats on reaching MVP stage!',
    },
  ],
});

eventBus.publish({
  type: 'business.stage_changed',
  payload: {
    businessId: 'abc-123',
    oldStage: 'idea',
    newStage: 'mvp',
  },
  timestamp: new Date(),
  businessId: 'abc-123',
});
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create EventBus class | 60 min |
| Define event catalog | 45 min |
| Implement trigger registration | 45 min |
| Add action execution | 60 min |
| Create event repository | 30 min |
| Add event history | 30 min |
| Integrate with existing features | 45 min |
| **Add commitment event triggers** | **45 min** |
| **Add monitoring event triggers** | **30 min** |
| **Integrate with accountability system** | **30 min** |
| Write tests | 60 min |

---

## Acceptance Criteria
- [ ] Events published and consumed
- [ ] Triggers execute actions
- [ ] Condition checking works
- [ ] At-least-once delivery
- [ ] Event history stored
- [ ] Idempotent actions
- [ ] Integration with workflows/agents
- [ ] **Commitment lifecycle events trigger follow-ups**
- [ ] **Monitoring alerts trigger research agent**
- [ ] **Pattern detection triggers coaching**

