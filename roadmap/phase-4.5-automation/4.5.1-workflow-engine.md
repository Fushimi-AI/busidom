# Feature 4.5.1: Workflow Engine

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 4.5.1 |
| **Phase** | 4.5 - Automation & Workflows |
| **Priority** | Critical |
| **Estimated Effort** | 8-10 hours |
| **Dependencies** | 4.2 (Mentor Agent), 2.4 (Business Entity), 4.6 (Dynamic Skills) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Build a state machine-based workflow engine that executes multi-step business processes, tracks progress, and integrates with AI agents **and dynamic skills** for intelligent execution.

**Enhanced with Dynamic Skills**: Workflows can now generate and execute custom code on-the-fly using Feature 4.6 (Dynamic Agent Skills System).

## Requirements

### Functional
1. Workflow definition (YAML/JSON)
2. State machine execution
3. Step types (task, decision, agent, wait, **skill**)
4. Progress tracking
5. Pause/resume support
6. Rollback/retry logic
7. **Dynamic skill generation and execution**

### Non-Functional
- Support 100+ concurrent workflows
- State persists to database
- Idempotent execution
- Audit trail

---

## Technical Specification

### Workflow Schema

```yaml
# Example: Customer Validation Workflow
workflow:
  id: customer_validation_idea_stage
  name: "Validate Customer Problem"
  trigger:
    stage: idea
    auto_start: true

  steps:
    - id: identify_problem
      type: task
      title: "Define the problem you're solving"
      description: "Write 1-2 sentences describing the specific problem"
      agent: mentor
      validation:
        min_length: 50

    - id: identify_customers
      type: task
      title: "Who has this problem?"
      description: "List 5 specific people/companies who experience this"
      validation:
        min_items: 5

    - id: research_alternatives
      type: agent
      agent: research
      prompt: "How are these customers solving this problem today?"

    - id: interview_decision
      type: decision
      prompt: "Have you interviewed at least 3 potential customers?"
      branches:
        yes: conduct_interviews
        no: schedule_interviews

    - id: schedule_interviews
      type: task
      title: "Schedule 3 customer interviews"
      next: wait_for_interviews

    - id: wait_for_interviews
      type: wait
      duration: "7 days"
      next: conduct_interviews

    - id: conduct_interviews
      type: checklist
      items:
        - "Interview customer 1"
        - "Interview customer 2"
        - "Interview customer 3"

    - id: analyze_interview_data
      type: skill
      task: "Extract common pain points from interview transcripts"
      input:
        transcripts: "{{stepData.conduct_interviews}}"
      description: "Parse interviews and identify top 5 recurring problems"

    - id: synthesize_learnings
      type: agent
      agent: mentor
      prompt: "Based on interviews, is this a real problem worth solving?"

    - id: final_decision
      type: decision
      prompt: "Validated: Should you continue with this idea?"
      branches:
        yes: complete_workflow
        no: pivot_or_stop
```

### Workflow Engine

```typescript
// src/core/workflows/workflow-engine.ts
export interface WorkflowDefinition {
  id: string;
  name: string;
  description?: string;
  trigger: WorkflowTrigger;
  steps: WorkflowStep[];
}

export interface WorkflowStep {
  id: string;
  type: 'task' | 'decision' | 'agent' | 'wait' | 'checklist' | 'skill';
  title?: string;
  description?: string;
  agent?: string;
  prompt?: string;
  task?: string;             // For skill steps: what the skill should do
  input?: Record<string, unknown>; // For skill steps: input data
  validation?: StepValidation;
  branches?: Record<string, string>; // For decision steps
  next?: string; // Next step ID
}

export interface WorkflowExecution {
  id: string;
  workflowId: string;
  businessId: string;
  status: 'active' | 'paused' | 'completed' | 'failed';
  currentStep: string;
  stepData: Record<string, unknown>;
  startedAt: Date;
  completedAt?: Date;
}

export class WorkflowEngine {
  constructor(
    private workflowRepo: WorkflowRepository,
    private executionRepo: ExecutionRepository,
    private agentRegistry: AgentRegistry,
    private skillGenerator: SkillGenerator,
    private skillExecutor: SkillExecutor
  ) {}

  async startWorkflow(
    workflowId: string,
    businessId: string
  ): Promise<WorkflowExecution> {
    const definition = await this.workflowRepo.findById(workflowId);

    const execution: WorkflowExecution = {
      id: generateId(),
      workflowId,
      businessId,
      status: 'active',
      currentStep: definition.steps[0].id,
      stepData: {},
      startedAt: new Date(),
    };

    await this.executionRepo.save(execution);
    return execution;
  }

  async executeStep(
    executionId: string,
    stepInput?: unknown
  ): Promise<StepResult> {
    const execution = await this.executionRepo.findById(executionId);
    const workflow = await this.workflowRepo.findById(execution.workflowId);
    const step = workflow.steps.find(s => s.id === execution.currentStep)!;

    let result: StepResult;

    switch (step.type) {
      case 'task':
        result = await this.executeTask(step, stepInput);
        break;

      case 'agent':
        result = await this.executeAgent(step, execution);
        break;

      case 'decision':
        result = await this.executeDecision(step, stepInput);
        break;

      case 'wait':
        result = await this.executeWait(step);
        break;

      case 'checklist':
        result = await this.executeChecklist(step, stepInput);
        break;

      case 'skill':
        result = await this.executeSkill(step, execution);
        break;
    }

    // Save step result
    execution.stepData[step.id] = result.data;

    // Move to next step
    if (result.complete) {
      const nextStepId = result.nextStep || step.next || this.getNextStep(workflow, step);

      if (nextStepId) {
        execution.currentStep = nextStepId;
        await this.executionRepo.save(execution);
      } else {
        execution.status = 'completed';
        execution.completedAt = new Date();
        await this.executionRepo.save(execution);
      }
    }

    return result;
  }

  private async executeAgent(
    step: WorkflowStep,
    execution: WorkflowExecution
  ): Promise<StepResult> {
    const agent = this.agentRegistry.get(step.agent!);

    // Build context from previous steps
    const context = this.buildContext(execution);
    const prompt = this.interpolatePrompt(step.prompt!, context);

    const result = await agent.execute(prompt);

    return {
      complete: true,
      data: result.output,
      confidence: result.confidence,
    };
  }

  private async executeSkill(
    step: WorkflowStep,
    execution: WorkflowExecution
  ): Promise<StepResult> {
    // Generate dynamic skill from task description
    const context = this.buildContext(execution);
    const task = this.interpolatePrompt(step.task!, context);

    // Resolve input data from previous steps
    const input = this.resolveInputData(step.input!, execution);

    // Generate skill
    const skill = await this.skillGenerator.generateSkill(
      task,
      JSON.stringify(context)
    );

    // Execute skill
    const result = await this.skillExecutor.execute(skill, input);

    if (!result.success) {
      throw new Error(`Skill execution failed: ${result.error}`);
    }

    return {
      complete: true,
      data: result.output,
      metadata: {
        skillId: skill.id,
        skillName: skill.name,
        executionTime: result.executionTime
      }
    };
  }

  private resolveInputData(
    inputSpec: Record<string, unknown>,
    execution: WorkflowExecution
  ): Record<string, unknown> {
    const resolved: Record<string, unknown> = {};

    for (const [key, value] of Object.entries(inputSpec)) {
      if (typeof value === 'string' && value.startsWith('{{') && value.endsWith('}}')) {
        // Template variable: {{stepData.step_id}}
        const path = value.slice(2, -2);
        resolved[key] = this.getValueByPath(execution, path);
      } else {
        resolved[key] = value;
      }
    }

    return resolved;
  }

  private getValueByPath(execution: WorkflowExecution, path: string): unknown {
    const parts = path.split('.');
    let value: any = execution;

    for (const part of parts) {
      value = value[part];
      if (value === undefined) {
        throw new Error(`Path not found: ${path}`);
      }
    }

    return value;
  }

  private async executeDecision(
    step: WorkflowStep,
    input: unknown
  ): Promise<StepResult> {
    const decision = input as string; // 'yes' or 'no' or custom
    const nextStep = step.branches?.[decision];

    if (!nextStep) {
      throw new Error(`Invalid decision: ${decision}`);
    }

    return {
      complete: true,
      data: decision,
      nextStep,
    };
  }

  async pauseWorkflow(executionId: string): Promise<void> {
    const execution = await this.executionRepo.findById(executionId);
    execution.status = 'paused';
    await this.executionRepo.save(execution);
  }

  async resumeWorkflow(executionId: string): Promise<void> {
    const execution = await this.executionRepo.findById(executionId);
    execution.status = 'active';
    await this.executionRepo.save(execution);
  }

  async getProgress(executionId: string): Promise<WorkflowProgress> {
    const execution = await this.executionRepo.findById(executionId);
    const workflow = await this.workflowRepo.findById(execution.workflowId);

    const currentIndex = workflow.steps.findIndex(s => s.id === execution.currentStep);
    const totalSteps = workflow.steps.length;

    return {
      currentStep: execution.currentStep,
      completedSteps: Object.keys(execution.stepData).length,
      totalSteps,
      percentage: Math.round((currentIndex / totalSteps) * 100),
      status: execution.status,
    };
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Define workflow schema | 45 min |
| Create WorkflowEngine class | 90 min |
| Implement step execution | 90 min |
| Add agent integration | 60 min |
| **Implement skill step execution** | **60 min** |
| **Add input data resolution** | **30 min** |
| Implement pause/resume | 30 min |
| Add progress tracking | 30 min |
| Create workflow repository | 45 min |
| Write integration tests | 75 min |

---

## Acceptance Criteria
- [ ] Workflows execute step-by-step
- [ ] Agent steps call AI agents
- [ ] Decision branching works
- [ ] **Skill steps generate and execute custom code**
- [ ] **Input data resolves from previous steps**
- [ ] Pause/resume works
- [ ] Progress tracked accurately
- [ ] State persists to DB
- [ ] Audit trail complete

