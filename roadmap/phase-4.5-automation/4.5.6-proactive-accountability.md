# Feature 4.5.6: Proactive Accountability System

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 4.5.6 |
| **Phase** | 5 - Automation & Workflows |
| **Priority** | Critical |
| **Estimated Effort** | 5-6 hours |
| **Dependencies** | 5.3 (Scheduler), 5.4 (Event Triggers), 3.3 (Semantic Retrieval) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Proactive accountability system that tracks user commitments from conversations, intelligently follows up at the right time, and learns from user behavior to optimize check-in timing.

**Key Differentiator vs ClawdBot**: Business-specific commitment tracking (talk to 10 customers, launch MVP, hire engineer) vs generic reminders.

---

## User Story

As a **founder**, I want **the AI to hold me accountable to what I said I'd do** so that **I actually execute instead of just talking about it**.

---

## Requirements

### Functional
1. Parse commitments from natural conversations
2. Extract deadline/timeframe from commitment
3. Schedule intelligent follow-ups (not just at deadline)
4. Track completion status
5. Learn optimal check-in timing per user
6. Differentiate between casual mention vs firm commitment
7. Handle recurring commitments (weekly goals)

### Non-Functional
- Extract 90%+ of explicit commitments
- 0% false positives on casual mentions
- Follow-up timing Â±2 hours of optimal
- < 3 follow-ups per commitment (not annoying)
- 80%+ users find check-ins helpful (not intrusive)

---

## Technical Specification

### Commitment Parser

```typescript
// src/core/accountability/commitment-parser.ts
import { Message } from '@/types';

export interface Commitment {
  id: string;
  userId: string;
  businessId: string;
  conversationId: string;
  text: string;                    // Raw commitment text
  parsedGoal: string;              // Clean goal description
  deadline: Date | null;           // When it should be done
  confidence: number;              // 0-1 (is this really a commitment?)
  category: CommitmentCategory;
  status: 'pending' | 'completed' | 'abandoned';
  createdAt: Date;
  completedAt: Date | null;
  followUps: FollowUp[];
}

export enum CommitmentCategory {
  CUSTOMER_VALIDATION = 'customer_validation',  // "Talk to 10 customers"
  PRODUCT = 'product',                          // "Launch MVP by Friday"
  HIRING = 'hiring',                            // "Hire first engineer this month"
  FUNDRAISING = 'fundraising',                  // "Send deck to 20 VCs"
  MARKETING = 'marketing',                      // "Post on Twitter daily"
  REVENUE = 'revenue',                          // "Close 5 customers this quarter"
  OTHER = 'other'
}

export interface FollowUp {
  id: string;
  scheduledFor: Date;
  status: 'pending' | 'sent' | 'skipped';
  type: 'early_check' | 'deadline' | 'overdue';
  response?: string;
}

export class CommitmentParser {
  constructor(private llm: LLMService) {}

  async parseMessage(message: Message): Promise<Commitment[]> {
    const prompt = `Analyze this message for FIRM COMMITMENTS (not casual mentions).

Message: "${message.content}"

A FIRM COMMITMENT must include:
1. First-person action ("I will", "I'm going to", "I'll")
2. Specific outcome (not vague like "think about" or "maybe")
3. Implied or explicit timeframe

Extract commitments as JSON:
{
  "commitments": [
    {
      "text": "original commitment text",
      "parsedGoal": "clean description",
      "deadline": "ISO date or null",
      "confidence": 0.0-1.0,
      "category": "customer_validation|product|hiring|etc",
      "reasoning": "why this is/isn't a commitment"
    }
  ]
}

Examples:
- "I'll talk to 10 customers this week" â†’ FIRM (action + outcome + timeframe)
- "I should probably talk to customers" â†’ NOT FIRM (vague, no commitment)
- "Maybe I'll launch next month" â†’ NOT FIRM (uncertain)
- "I'm going to send the deck to investors tomorrow" â†’ FIRM

Only return commitments with confidence >= 0.7`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You extract commitments from text.' },
      { role: 'user', content: prompt }
    ]);

    const parsed = JSON.parse(response.content);

    return parsed.commitments
      .filter((c: any) => c.confidence >= 0.7)
      .map((c: any) => ({
        id: generateId(),
        userId: message.user_id,
        businessId: message.business_id,
        conversationId: message.conversation_id,
        text: c.text,
        parsedGoal: c.parsedGoal,
        deadline: c.deadline ? new Date(c.deadline) : null,
        confidence: c.confidence,
        category: c.category,
        status: 'pending',
        createdAt: new Date(),
        completedAt: null,
        followUps: this.scheduleFollowUps(c.deadline)
      }));
  }

  private scheduleFollowUps(deadline: Date | null): FollowUp[] {
    if (!deadline) {
      // No explicit deadline â†’ check in 3 days
      return [
        {
          id: generateId(),
          scheduledFor: addDays(new Date(), 3),
          status: 'pending',
          type: 'early_check'
        }
      ];
    }

    const now = new Date();
    const timeUntilDeadline = deadline.getTime() - now.getTime();
    const days = timeUntilDeadline / (1000 * 60 * 60 * 24);

    const followUps: FollowUp[] = [];

    // Early check-in (halfway to deadline, minimum 1 day)
    if (days > 2) {
      followUps.push({
        id: generateId(),
        scheduledFor: new Date(now.getTime() + (timeUntilDeadline / 2)),
        status: 'pending',
        type: 'early_check'
      });
    }

    // Deadline check-in
    followUps.push({
      id: generateId(),
      scheduledFor: deadline,
      status: 'pending',
      type: 'deadline'
    });

    // Overdue check-in (1 day after)
    followUps.push({
      id: generateId(),
      scheduledFor: addDays(deadline, 1),
      status: 'pending',
      type: 'overdue'
    });

    return followUps;
  }
}
```

### Accountability Service

```typescript
// src/core/accountability/accountability.service.ts
export class AccountabilityService {
  constructor(
    private commitmentRepo: CommitmentRepository,
    private parser: CommitmentParser,
    private notificationService: NotificationService,
    private llm: LLMService
  ) {}

  async trackMessage(message: Message): Promise<void> {
    // Parse commitments from message
    const commitments = await this.parser.parseMessage(message);

    for (const commitment of commitments) {
      await this.commitmentRepo.create(commitment);

      // Schedule follow-ups
      for (const followUp of commitment.followUps) {
        await this.scheduleFollowUp(commitment.id, followUp);
      }
    }
  }

  async executeFollowUp(commitmentId: string, followUpId: string): Promise<void> {
    const commitment = await this.commitmentRepo.findById(commitmentId);

    if (commitment.status !== 'pending') {
      // Already completed/abandoned, skip
      return;
    }

    // Generate contextual check-in message
    const message = await this.generateCheckInMessage(commitment);

    // Send notification
    await this.notificationService.send({
      userId: commitment.userId,
      type: 'commitment_followup',
      title: 'Progress Check-In',
      body: message,
      data: { commitmentId }
    });

    // Mark follow-up as sent
    await this.commitmentRepo.updateFollowUp(commitmentId, followUpId, {
      status: 'sent'
    });
  }

  private async generateCheckInMessage(commitment: Commitment): Promise<string> {
    const context = await this.getBusinessContext(commitment.businessId);

    const prompt = `Generate a friendly but firm check-in message for this commitment:

Commitment: "${commitment.parsedGoal}"
Original: "${commitment.text}"
Deadline: ${commitment.deadline ? commitment.deadline.toDateString() : 'No explicit deadline'}
Category: ${commitment.category}

Business Context:
${context}

Requirements:
1. Remind them what they committed to (use their exact words)
2. Ask for progress (not yes/no, open-ended)
3. Keep it brief (1-2 sentences)
4. Tone: Supportive but firm (like a good co-founder)
5. No generic corporate speak

Good examples:
- "You said you'd talk to 10 customers this week. How many have you reached?"
- "Friday's here - did you send that deck to investors like you planned?"
- "You committed to posting on Twitter daily. How's that going?"

Bad examples:
- "Just checking in!" (too vague)
- "Have you completed your task?" (robotic)
- "I hope you're doing well! How are things?" (too casual, not specific)`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You write accountability check-in messages.' },
      { role: 'user', content: prompt }
    ]);

    return response.content;
  }

  async markCompleted(commitmentId: string, evidence: string): Promise<void> {
    await this.commitmentRepo.update(commitmentId, {
      status: 'completed',
      completedAt: new Date()
    });

    // Cancel pending follow-ups
    const commitment = await this.commitmentRepo.findById(commitmentId);
    for (const followUp of commitment.followUps) {
      if (followUp.status === 'pending') {
        await this.cancelFollowUp(commitmentId, followUp.id);
      }
    }

    // Send congratulations
    await this.notificationService.send({
      userId: commitment.userId,
      type: 'commitment_completed',
      title: 'âœ… Commitment Completed!',
      body: `Nice work on: ${commitment.parsedGoal}`,
      data: { commitmentId }
    });
  }

  async getUserAccountabilityScore(userId: string): Promise<number> {
    const commitments = await this.commitmentRepo.findByUserId(userId);

    if (commitments.length === 0) return 1.0;

    const completed = commitments.filter(c => c.status === 'completed').length;
    return completed / commitments.length;
  }
}
```

### Intelligent Timing Optimizer

```typescript
// src/core/accountability/timing-optimizer.ts
export class FollowUpTimingOptimizer {
  constructor(private commitmentRepo: CommitmentRepository) {}

  async optimizeFollowUpTime(
    commitment: Commitment,
    followUp: FollowUp
  ): Promise<Date> {
    // Learn from user's response patterns
    const userHistory = await this.commitmentRepo.findByUserId(commitment.userId);

    const responseTimes = userHistory
      .flatMap(c => c.followUps)
      .filter(f => f.response)
      .map(f => this.extractResponseTime(f));

    if (responseTimes.length === 0) {
      // No history, use default
      return followUp.scheduledFor;
    }

    // Find most common response hour
    const hourCounts = new Map<number, number>();
    responseTimes.forEach(time => {
      const hour = time.getHours();
      hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
    });

    const optimalHour = Array.from(hourCounts.entries())
      .sort((a, b) => b[1] - a[1])[0][0];

    // Adjust followUp time to optimal hour
    const optimized = new Date(followUp.scheduledFor);
    optimized.setHours(optimalHour, 0, 0, 0);

    return optimized;
  }

  private extractResponseTime(followUp: FollowUp): Date {
    // Extract when user responded (from response timestamp)
    // Simplified - in real implementation, track response time
    return new Date();
  }
}
```

---

## CLI Integration

```typescript
// src/cli/commands/accountability.command.ts
export async function showAccountability() {
  const accountabilityService = container.resolve<AccountabilityService>('AccountabilityService');
  const currentUser = await getCurrentUser();

  const pending = await commitmentRepo.findByUserId(currentUser.id, { status: 'pending' });

  console.log(chalk.bold('\nðŸ“‹ Your Active Commitments\n'));

  for (const commitment of pending) {
    const daysUntil = Math.ceil(
      (commitment.deadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
    );

    console.log(chalk.blue(`â€¢ ${commitment.parsedGoal}`));
    console.log(chalk.gray(`  Committed: ${formatRelativeTime(commitment.createdAt)}`));

    if (commitment.deadline) {
      const color = daysUntil < 0 ? chalk.red : daysUntil < 2 ? chalk.yellow : chalk.gray;
      console.log(color(`  Deadline: ${daysUntil} days ${daysUntil < 0 ? 'overdue' : 'remaining'}`));
    }

    console.log();
  }

  const score = await accountabilityService.getUserAccountabilityScore(currentUser.id);
  console.log(chalk.bold(`Your Accountability Score: ${(score * 100).toFixed(0)}%\n`));
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create CommitmentParser | 90 min |
| Build LLM-based extraction | 60 min |
| Implement AccountabilityService | 60 min |
| Add follow-up scheduling | 45 min |
| Build timing optimizer | 45 min |
| Create CLI commands | 30 min |
| Write tests | 40 min |

---

## Acceptance Criteria
- [ ] Extracts 90%+ of firm commitments
- [ ] < 5% false positives on casual mentions
- [ ] Schedules follow-ups at intelligent times
- [ ] Learns optimal check-in timing per user
- [ ] Generates contextual check-in messages
- [ ] Tracks completion status
- [ ] Shows accountability score

---

## Success Metrics

**Engagement:**
- 70%+ users respond to check-ins
- 80%+ users find check-ins helpful (survey)

**Behavioral Change:**
- 50%+ increase in commitment completion vs no accountability
- 30%+ of users upgrade to paid for better accountability

**Differentiation:**
- #1 requested feature in user interviews
- Cited in 50%+ of testimonials

---

## References

- [Proactive AI Agents: Anticipating Needs Before You Do](https://www.hey-steve.com/insights/proactive-ai-agents-anticipating-needs-before-you-do)
- [Proactive Service: Using AI to Anticipate Customer Needs](https://www.genesys.com/blog/post/proactive-service-using-ai-to-anticipate-customer-needs)
- [When AI-Based Agents Are Proactive](https://link.springer.com/article/10.1007/s12599-024-00918-y)
