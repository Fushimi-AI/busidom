# Feature 4.5.7: Always-On Monitoring Engine

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 4.5.7 |
| **Phase** | 5 - Automation & Workflows |
| **Priority** | High |
| **Estimated Effort** | 6-7 hours |
| **Dependencies** | 5.3 (Scheduler), 5.4 (Event Triggers), 3.3 (Semantic Retrieval) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Always-on background monitoring engine that tracks business-relevant events (competitor changes, customer mentions, market shifts) using task-based polling. Proactively alerts users when action is needed.

**Key Differentiator vs Generic Monitoring**: Business-context-aware (monitors what matters for your stage), resource-efficient (< 50MB RAM idle), intelligent alerting (only when actionable).

---

## User Story

As a **founder**, I want **the AI to monitor important business signals in the background** so that **I don't miss opportunities or threats while focused on execution**.

---

## Requirements

### Functional
1. Define monitoring tasks via natural language
2. Task-based polling (not high-frequency continuous)
3. Monitor multiple channels (web, APIs, feeds)
4. Intelligent change detection (semantic, not just literal)
5. Contextual alerting (only when actionable)
6. Integration with accountability system
7. Resource usage limits (CPU, memory, network)

### Non-Functional
- < 50MB RAM when idle
- < 5% CPU average
- Configurable poll intervals (min 15 min)
- 99%+ uptime for active monitors
- < 500ms to process monitoring results
- Support 20+ concurrent monitoring tasks

---

## Technical Specification

### Monitor Definition

```typescript
// src/core/monitoring/monitor.types.ts
export interface MonitorTask {
  id: string;
  userId: string;
  businessId: string;
  name: string;                      // "Track competitor pricing"
  description: string;               // Natural language description
  type: MonitorType;
  config: MonitorConfig;
  schedule: MonitorSchedule;
  status: 'active' | 'paused' | 'error';
  lastRun: Date | null;
  nextRun: Date;
  createdAt: Date;
}

export enum MonitorType {
  WEB_SCRAPE = 'web_scrape',         // Monitor website changes
  API_POLL = 'api_poll',             // Poll API endpoints
  RSS_FEED = 'rss_feed',             // Track RSS/Atom feeds
  SOCIAL_MENTION = 'social_mention', // Track social media mentions
  MARKET_DATA = 'market_data',       // Track market/industry data
  CUSTOM = 'custom'                  // Custom monitoring logic
}

export interface MonitorConfig {
  // Web scrape config
  url?: string;
  selector?: string;                 // CSS selector for specific elements

  // API poll config
  endpoint?: string;
  headers?: Record<string, string>;

  // Social mention config
  keywords?: string[];
  platforms?: string[];              // Twitter, Reddit, HN, etc.

  // Change detection
  changeThreshold: number;           // 0-1 (how much change to alert on)
  semanticComparison: boolean;       // Use embeddings vs literal diff

  // Alerting
  alertOnChange: boolean;
  alertConditions?: string;          // Natural language conditions
}

export interface MonitorSchedule {
  interval: number;                  // Minutes between checks
  timezone: string;
  activeHours?: {                    // Only run during these hours
    start: number;                   // 0-23
    end: number;                     // 0-23
  };
  activeDays?: number[];             // 0-6 (Sunday-Saturday)
}

export interface MonitorResult {
  id: string;
  monitorId: string;
  timestamp: Date;
  success: boolean;
  data: any;                         // Raw data fetched
  changeDetected: boolean;
  changeSummary?: string;            // AI-generated summary of changes
  previousData?: any;
  alert: boolean;                    // Should we alert the user?
  alertReason?: string;
}
```

### Monitoring Engine

```typescript
// src/core/monitoring/monitoring.engine.ts
import { EventEmitter } from 'events';

export class MonitoringEngine extends EventEmitter {
  private activeMonitors: Map<string, NodeJS.Timeout> = new Map();
  private resourceTracker: ResourceTracker;

  constructor(
    private monitorRepo: MonitorRepository,
    private executors: Map<MonitorType, MonitorExecutor>,
    private changeDetector: ChangeDetector,
    private llm: LLMService,
    private notificationService: NotificationService
  ) {
    super();
    this.resourceTracker = new ResourceTracker({
      maxMemoryMB: 50,
      maxCpuPercent: 5
    });
  }

  async start(): Promise<void> {
    // Load all active monitors
    const monitors = await this.monitorRepo.findActive();

    for (const monitor of monitors) {
      await this.scheduleMonitor(monitor);
    }

    console.log(`[MonitoringEngine] Started with ${monitors.length} active monitors`);
  }

  async stop(): Promise<void> {
    // Stop all monitors
    for (const [monitorId, timeout] of this.activeMonitors) {
      clearTimeout(timeout);
    }

    this.activeMonitors.clear();
    console.log('[MonitoringEngine] Stopped');
  }

  async addMonitor(monitor: MonitorTask): Promise<void> {
    await this.monitorRepo.create(monitor);
    await this.scheduleMonitor(monitor);

    this.emit('monitor:added', monitor);
  }

  async removeMonitor(monitorId: string): Promise<void> {
    // Stop the monitor
    const timeout = this.activeMonitors.get(monitorId);
    if (timeout) {
      clearTimeout(timeout);
      this.activeMonitors.delete(monitorId);
    }

    // Mark as deleted
    await this.monitorRepo.delete(monitorId);

    this.emit('monitor:removed', monitorId);
  }

  private async scheduleMonitor(monitor: MonitorTask): Promise<void> {
    const executeMonitor = async () => {
      try {
        // Check resource limits
        if (!this.resourceTracker.canExecute()) {
          console.warn(`[Monitor ${monitor.id}] Skipping due to resource limits`);
          return;
        }

        // Execute the monitor
        const result = await this.executeMonitor(monitor);

        // Save result
        await this.monitorRepo.saveResult(result);

        // If change detected and alert needed, notify user
        if (result.alert) {
          await this.handleAlert(monitor, result);
        }

        // Update monitor
        await this.monitorRepo.update(monitor.id, {
          lastRun: new Date(),
          nextRun: this.calculateNextRun(monitor)
        });

        this.emit('monitor:executed', { monitor, result });

      } catch (error) {
        console.error(`[Monitor ${monitor.id}] Error:`, error);

        await this.monitorRepo.update(monitor.id, {
          status: 'error',
          lastRun: new Date()
        });

        this.emit('monitor:error', { monitor, error });
      }
    };

    // Initial execution
    if (!monitor.lastRun) {
      await executeMonitor();
    }

    // Schedule recurring execution
    const intervalMs = monitor.schedule.interval * 60 * 1000;
    const timeout = setInterval(executeMonitor, intervalMs);

    this.activeMonitors.set(monitor.id, timeout as any);
  }

  private async executeMonitor(monitor: MonitorTask): Promise<MonitorResult> {
    const executor = this.executors.get(monitor.type);

    if (!executor) {
      throw new Error(`No executor for monitor type: ${monitor.type}`);
    }

    // Fetch current data
    const data = await executor.execute(monitor.config);

    // Get previous data
    const previousResult = await this.monitorRepo.getLatestResult(monitor.id);
    const previousData = previousResult?.data;

    // Detect changes
    const changeDetection = previousData
      ? await this.changeDetector.detectChange(
          previousData,
          data,
          monitor.config.semanticComparison
        )
      : { changed: true, summary: 'Initial data fetch', score: 1.0 };

    // Determine if we should alert
    const shouldAlert = await this.shouldAlert(
      monitor,
      changeDetection,
      data,
      previousData
    );

    return {
      id: generateId(),
      monitorId: monitor.id,
      timestamp: new Date(),
      success: true,
      data,
      changeDetected: changeDetection.changed,
      changeSummary: changeDetection.summary,
      previousData,
      alert: shouldAlert,
      alertReason: shouldAlert ? changeDetection.summary : undefined
    };
  }

  private async shouldAlert(
    monitor: MonitorTask,
    changeDetection: { changed: boolean; summary: string; score: number },
    currentData: any,
    previousData: any
  ): Promise<boolean> {
    // No alert if no change
    if (!changeDetection.changed) {
      return false;
    }

    // No alert if change below threshold
    if (changeDetection.score < monitor.config.changeThreshold) {
      return false;
    }

    // No alert if alertOnChange is disabled
    if (!monitor.config.alertOnChange) {
      return false;
    }

    // If custom alert conditions, evaluate with LLM
    if (monitor.config.alertConditions) {
      const isActionable = await this.evaluateAlertConditions(
        monitor.config.alertConditions,
        changeDetection.summary,
        currentData,
        previousData
      );

      return isActionable;
    }

    // Default: alert on any significant change
    return true;
  }

  private async evaluateAlertConditions(
    conditions: string,
    changeSummary: string,
    currentData: any,
    previousData: any
  ): Promise<boolean> {
    const prompt = `Determine if this change warrants alerting the user.

Alert Conditions: "${conditions}"

Change Summary: "${changeSummary}"

Current Data: ${JSON.stringify(currentData, null, 2)}
Previous Data: ${JSON.stringify(previousData, null, 2)}

Should we alert the user? Respond with JSON:
{
  "alert": true/false,
  "reasoning": "why this is/isn't actionable"
}`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You evaluate if monitoring changes are actionable.' },
      { role: 'user', content: prompt }
    ]);

    const parsed = JSON.parse(response.content);
    return parsed.alert;
  }

  private async handleAlert(monitor: MonitorTask, result: MonitorResult): Promise<void> {
    // Generate contextual alert message
    const message = await this.generateAlertMessage(monitor, result);

    // Send notification
    await this.notificationService.send({
      userId: monitor.userId,
      type: 'monitor_alert',
      title: `Update: ${monitor.name}`,
      body: message,
      data: {
        monitorId: monitor.id,
        resultId: result.id
      }
    });

    this.emit('monitor:alert', { monitor, result });
  }

  private async generateAlertMessage(
    monitor: MonitorTask,
    result: MonitorResult
  ): Promise<string> {
    const prompt = `Generate a concise alert message for this monitoring result.

Monitor: "${monitor.name}"
Description: "${monitor.description}"

Change Detected: ${result.changeSummary}

Requirements:
1. Be specific about what changed
2. Explain why this matters
3. Suggest a potential action (if relevant)
4. Keep it under 3 sentences
5. Tone: Informative but urgent

Good examples:
- "Your competitor dropped pricing by 20% ($99 ‚Üí $79). This could impact conversions. Consider reviewing your pricing strategy."
- "Your product was mentioned on Hacker News (87 points). Good opportunity to engage in comments and build awareness."
- "New competitor launched with similar features. They're offering a free tier - might be worth analyzing their positioning."

Bad examples:
- "A change was detected." (too vague)
- "Something happened with your monitor." (not specific)`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You write monitoring alert messages.' },
      { role: 'user', content: prompt }
    ]);

    return response.content;
  }

  private calculateNextRun(monitor: MonitorTask): Date {
    const now = new Date();
    const intervalMs = monitor.schedule.interval * 60 * 1000;
    return new Date(now.getTime() + intervalMs);
  }
}
```

### Monitor Executors

```typescript
// src/core/monitoring/executors/web-scrape.executor.ts
import axios from 'axios';
import * as cheerio from 'cheerio';

export class WebScrapeExecutor implements MonitorExecutor {
  async execute(config: MonitorConfig): Promise<any> {
    const response = await axios.get(config.url!, {
      timeout: 10000,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; BusinessOS-Monitor/1.0)'
      }
    });

    const $ = cheerio.load(response.data);

    if (config.selector) {
      // Extract specific elements
      const elements = $(config.selector);
      return elements.map((i, el) => ({
        text: $(el).text().trim(),
        html: $(el).html()
      })).get();
    }

    // Return full page text
    return {
      title: $('title').text(),
      text: $('body').text().trim(),
      html: response.data
    };
  }
}

// src/core/monitoring/executors/api-poll.executor.ts
export class ApiPollExecutor implements MonitorExecutor {
  async execute(config: MonitorConfig): Promise<any> {
    const response = await axios.get(config.endpoint!, {
      timeout: 10000,
      headers: config.headers || {}
    });

    return response.data;
  }
}

// src/core/monitoring/executors/social-mention.executor.ts
export class SocialMentionExecutor implements MonitorExecutor {
  async execute(config: MonitorConfig): Promise<any> {
    // This would integrate with APIs like:
    // - Twitter API
    // - Reddit API (via PRAW equivalent)
    // - Hacker News Algolia API
    // For now,Á§∫‰æã with Hacker News

    const mentions: any[] = [];

    for (const keyword of config.keywords || []) {
      const response = await axios.get(
        `https://hn.algolia.com/api/v1/search?query=${encodeURIComponent(keyword)}&tags=story`
      );

      mentions.push(...response.data.hits);
    }

    return mentions;
  }
}
```

### Change Detector

```typescript
// src/core/monitoring/change-detector.ts
export class ChangeDetector {
  constructor(
    private embeddingService: EmbeddingService,
    private llm: LLMService
  ) {}

  async detectChange(
    previousData: any,
    currentData: any,
    semantic: boolean = false
  ): Promise<{ changed: boolean; summary: string; score: number }> {
    // Simple case: identical data
    if (JSON.stringify(previousData) === JSON.stringify(currentData)) {
      return {
        changed: false,
        summary: 'No changes detected',
        score: 0.0
      };
    }

    if (semantic) {
      return this.detectSemanticChange(previousData, currentData);
    } else {
      return this.detectLiteralChange(previousData, currentData);
    }
  }

  private async detectSemanticChange(
    previousData: any,
    currentData: any
  ): Promise<{ changed: boolean; summary: string; score: number }> {
    // Convert to text
    const prevText = this.dataToText(previousData);
    const currText = this.dataToText(currentData);

    // Generate embeddings
    const [prevEmbedding, currEmbedding] = await Promise.all([
      this.embeddingService.embed(prevText),
      this.embeddingService.embed(currText)
    ]);

    // Calculate cosine similarity
    const similarity = this.cosineSimilarity(prevEmbedding, currEmbedding);
    const changeScore = 1 - similarity;

    // If change is significant, generate summary
    if (changeScore > 0.1) {
      const summary = await this.generateChangeSummary(prevText, currText);

      return {
        changed: true,
        summary,
        score: changeScore
      };
    }

    return {
      changed: false,
      summary: 'Minor semantic changes detected',
      score: changeScore
    };
  }

  private async detectLiteralChange(
    previousData: any,
    currentData: any
  ): Promise<{ changed: boolean; summary: string; score: number }> {
    const prevText = this.dataToText(previousData);
    const currText = this.dataToText(currentData);

    // Simple character-level diff
    const diffRatio = this.calculateDiffRatio(prevText, currText);

    if (diffRatio > 0.05) {
      const summary = await this.generateChangeSummary(prevText, currText);

      return {
        changed: true,
        summary,
        score: diffRatio
      };
    }

    return {
      changed: false,
      summary: 'Minimal changes detected',
      score: diffRatio
    };
  }

  private async generateChangeSummary(
    previousText: string,
    currentText: string
  ): Promise<string> {
    const prompt = `Summarize what changed between these two versions.

PREVIOUS:
${previousText.slice(0, 1000)}

CURRENT:
${currentText.slice(0, 1000)}

Provide a concise 1-2 sentence summary of the key changes.`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You summarize changes in monitored data.' },
      { role: 'user', content: prompt }
    ]);

    return response.content;
  }

  private dataToText(data: any): string {
    if (typeof data === 'string') {
      return data;
    }

    if (Array.isArray(data)) {
      return data.map(item => this.dataToText(item)).join('\n');
    }

    if (typeof data === 'object') {
      return JSON.stringify(data, null, 2);
    }

    return String(data);
  }

  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));

    return dotProduct / (magnitudeA * magnitudeB);
  }

  private calculateDiffRatio(a: string, b: string): number {
    // Simple Levenshtein-like ratio
    const maxLen = Math.max(a.length, b.length);
    if (maxLen === 0) return 0;

    let differences = 0;
    for (let i = 0; i < maxLen; i++) {
      if (a[i] !== b[i]) differences++;
    }

    return differences / maxLen;
  }
}
```

### Resource Tracker

```typescript
// src/core/monitoring/resource-tracker.ts
import * as os from 'os';

export class ResourceTracker {
  private maxMemoryMB: number;
  private maxCpuPercent: number;
  private cpuUsageHistory: number[] = [];

  constructor(options: { maxMemoryMB: number; maxCpuPercent: number }) {
    this.maxMemoryMB = options.maxMemoryMB;
    this.maxCpuPercent = options.maxCpuPercent;
  }

  canExecute(): boolean {
    const memoryOk = this.checkMemory();
    const cpuOk = this.checkCpu();

    return memoryOk && cpuOk;
  }

  private checkMemory(): boolean {
    const usage = process.memoryUsage();
    const usedMB = usage.heapUsed / 1024 / 1024;

    return usedMB < this.maxMemoryMB;
  }

  private checkCpu(): boolean {
    // Track CPU usage (simplified)
    const cpus = os.cpus();
    let totalIdle = 0;
    let totalTick = 0;

    for (const cpu of cpus) {
      for (const type in cpu.times) {
        totalTick += cpu.times[type as keyof typeof cpu.times];
      }
      totalIdle += cpu.times.idle;
    }

    const currentUsage = 100 - (100 * totalIdle / totalTick);

    this.cpuUsageHistory.push(currentUsage);
    if (this.cpuUsageHistory.length > 10) {
      this.cpuUsageHistory.shift();
    }

    const avgUsage = this.cpuUsageHistory.reduce((a, b) => a + b, 0) / this.cpuUsageHistory.length;

    return avgUsage < this.maxCpuPercent;
  }

  getStats(): { memoryMB: number; cpuPercent: number } {
    const usage = process.memoryUsage();
    const memoryMB = usage.heapUsed / 1024 / 1024;
    const cpuPercent = this.cpuUsageHistory.length > 0
      ? this.cpuUsageHistory.reduce((a, b) => a + b, 0) / this.cpuUsageHistory.length
      : 0;

    return { memoryMB, cpuPercent };
  }
}
```

---

## CLI Integration

```typescript
// src/cli/commands/monitor.command.ts
export async function addMonitor() {
  const monitoringEngine = container.resolve<MonitoringEngine>('MonitoringEngine');
  const currentUser = await getCurrentUser();

  console.log(chalk.bold('\nüîç Add Monitoring Task\n'));

  // Get monitor details from user
  const name = await askQuestion('What should we monitor? (e.g., "Track competitor pricing"): ');
  const description = await askQuestion('Describe what to look for: ');

  // Determine monitor type
  const typeChoice = await askChoice('Monitor type:', [
    'Web page (scrape HTML)',
    'API endpoint (JSON)',
    'Social mentions (Twitter/HN)',
    'RSS/Atom feed'
  ]);

  const type = {
    'Web page (scrape HTML)': MonitorType.WEB_SCRAPE,
    'API endpoint (JSON)': MonitorType.API_POLL,
    'Social mentions (Twitter/HN)': MonitorType.SOCIAL_MENTION,
    'RSS/Atom feed': MonitorType.RSS_FEED
  }[typeChoice]!;

  // Get type-specific config
  let config: MonitorConfig;

  if (type === MonitorType.WEB_SCRAPE) {
    const url = await askQuestion('URL to monitor: ');
    const selector = await askQuestion('CSS selector (optional, leave blank for full page): ');

    config = {
      url,
      selector: selector || undefined,
      changeThreshold: 0.2,
      semanticComparison: true,
      alertOnChange: true
    };
  } else if (type === MonitorType.API_POLL) {
    const endpoint = await askQuestion('API endpoint URL: ');

    config = {
      endpoint,
      changeThreshold: 0.1,
      semanticComparison: false,
      alertOnChange: true
    };
  } else {
    // Social mentions
    const keywordsStr = await askQuestion('Keywords to track (comma-separated): ');
    const keywords = keywordsStr.split(',').map(k => k.trim());

    config = {
      keywords,
      platforms: ['hackernews', 'twitter'],
      changeThreshold: 0.0,
      semanticComparison: false,
      alertOnChange: true
    };
  }

  // Schedule
  const intervalStr = await askQuestion('Check interval in minutes (minimum 15): ');
  const interval = Math.max(15, parseInt(intervalStr));

  const monitor: MonitorTask = {
    id: generateId(),
    userId: currentUser.id,
    businessId: currentUser.currentBusinessId,
    name,
    description,
    type,
    config,
    schedule: {
      interval,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    status: 'active',
    lastRun: null,
    nextRun: new Date(),
    createdAt: new Date()
  };

  await monitoringEngine.addMonitor(monitor);

  console.log(chalk.green(`\n‚úÖ Monitor "${name}" created and scheduled\n`));
  console.log(chalk.gray(`Will check every ${interval} minutes\n`));
}

export async function listMonitors() {
  const monitorRepo = container.resolve<MonitorRepository>('MonitorRepository');
  const currentUser = await getCurrentUser();

  const monitors = await monitorRepo.findByUserId(currentUser.id);

  console.log(chalk.bold('\nüîç Your Active Monitors\n'));

  for (const monitor of monitors) {
    const statusColor = monitor.status === 'active' ? chalk.green : chalk.red;

    console.log(chalk.blue(`‚Ä¢ ${monitor.name}`));
    console.log(chalk.gray(`  ${monitor.description}`));
    console.log(statusColor(`  Status: ${monitor.status}`));
    console.log(chalk.gray(`  Interval: Every ${monitor.schedule.interval} minutes`));

    if (monitor.lastRun) {
      console.log(chalk.gray(`  Last run: ${formatRelativeTime(monitor.lastRun)}`));
    }

    console.log();
  }

  if (monitors.length === 0) {
    console.log(chalk.gray('No monitors configured yet.\n'));
    console.log(chalk.gray('Run `business-os monitor add` to create one.\n'));
  }
}
```

---

## Integration with Accountability System

```typescript
// src/core/monitoring/integrations/accountability-monitor.ts
export class AccountabilityMonitor {
  constructor(
    private monitoringEngine: MonitoringEngine,
    private accountabilityService: AccountabilityService
  ) {
    // Listen for commitment events
    this.accountabilityService.on('commitment:created', this.onCommitmentCreated.bind(this));
  }

  private async onCommitmentCreated(commitment: Commitment): Promise<void> {
    // Some commitments might need monitoring
    // Example: "Launch MVP" ‚Üí monitor website for launch
    // Example: "Get 10 customers" ‚Üí monitor CRM/Stripe for new customers

    if (commitment.category === CommitmentCategory.PRODUCT) {
      // Auto-create monitor for product launches
      const shouldMonitor = await this.shouldAutoMonitor(commitment);

      if (shouldMonitor) {
        await this.createCommitmentMonitor(commitment);
      }
    }
  }

  private async shouldAutoMonitor(commitment: Commitment): Promise<boolean> {
    // Use LLM to determine if commitment needs monitoring
    // Example: "Launch MVP by Friday" ‚Üí yes
    // Example: "Think about pricing" ‚Üí no
    return false; // Simplified for now
  }

  private async createCommitmentMonitor(commitment: Commitment): Promise<void> {
    // Create monitoring task based on commitment
    // Implementation depends on commitment type
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create MonitorTask model & repository | 45 min |
| Implement MonitoringEngine | 90 min |
| Build monitor executors (web, API, social) | 75 min |
| Implement ChangeDetector (semantic + literal) | 60 min |
| Build ResourceTracker | 30 min |
| Create CLI commands | 45 min |
| Integration with accountability system | 30 min |
| Write tests | 45 min |

---

## Acceptance Criteria
- [ ] Support 20+ concurrent monitors without performance degradation
- [ ] < 50MB RAM when idle
- [ ] < 5% average CPU usage
- [ ] Semantic change detection with > 85% accuracy
- [ ] Intelligent alerting (< 10% false positives)
- [ ] Configurable poll intervals (min 15 min)
- [ ] Integration with event triggers and accountability

---

## Success Metrics

**Resource Efficiency:**
- < 50MB RAM idle (measured via process.memoryUsage())
- < 100MB RAM with 20 active monitors
- < 5% CPU average

**Monitoring Accuracy:**
- 90%+ change detection accuracy
- < 10% false positive alert rate
- 95%+ uptime for active monitors

**User Engagement:**
- 50%+ users create at least one monitor
- 70%+ users find alerts actionable (survey)
- Average 3+ monitors per active user

**Business Impact:**
- "Helped me catch competitor changes" cited in 30%+ testimonials
- 20%+ upgrade to paid for more monitoring capacity

---

## References

- [Azure AI Foundry: Observability for AI Agents](https://learn.microsoft.com/en-us/azure/ai-foundry/concepts/observability)
- [AI Agent Observability Best Practices](https://www.digitalocean.com/community/tutorials/ai-agent-observability)
- [Continuous Monitoring Architecture Patterns](https://martinfowler.com/articles/continuousMonitoring.html)
