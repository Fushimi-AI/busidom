# Feature 3.3: Semantic Retrieval (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-3.3 |
| **Phase** | 3 - Intelligence & Vector Search (CLI) |
| **Priority** | Critical |
| **Estimated Effort** | 3-4 hours |
| **Dependencies** | CLI-3.1 (Vector Setup), CLI-3.2 (Embedding Generation) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement semantic search to retrieve relevant past conversations, business context, and insights based on meaning rather than keyword matching.

## User Story

As a **CLI user**, I want **the AI to find relevant past conversations** so that **it can give context-aware advice based on my history**.

---

## Requirements

### Functional
1. Search by semantic similarity (not keywords)
2. Support multi-source retrieval (messages + business context)
3. Filter by conversation, business, date range
4. Return ranked results with confidence scores
5. Hybrid search (semantic + keyword fallback)

### Non-Functional
- Search latency < 200ms for 10K vectors
- Top-K retrieval (K = 5-20)
- Cosine similarity threshold: 0.7+
- Support up to 100K embeddings locally

---

## Technical Specification

```typescript
// src/core/intelligence/retrieval.service.ts
export interface RetrievalOptions {
  sourceTypes?: ('message' | 'business_context' | 'workflow')[];
  businessId?: string;
  conversationId?: string;
  dateRange?: { start: number; end: number };
  limit?: number;
  threshold?: number;
}

export interface RetrievalResult {
  id: string;
  sourceType: string;
  sourceId: string;
  content: string;
  similarity: number;
  metadata: Record<string, any>;
}

export class RetrievalService {
  constructor(
    private vectorStore: IVectorStore,
    private embeddingService: EmbeddingService
  ) {}

  async search(
    query: string,
    options: RetrievalOptions = {}
  ): Promise<RetrievalResult[]> {
    const {
      sourceTypes = ['message', 'business_context'],
      limit = 10,
      threshold = 0.7,
      businessId,
      conversationId,
      dateRange
    } = options;

    // Generate embedding for query
    const queryEmbedding = await this.embeddingService.generateEmbedding(query);

    // Search vector store
    const results = await this.vectorStore.search(queryEmbedding, {
      limit,
      threshold,
      filter: {
        sourceTypes,
        businessId,
        conversationId,
        dateRange
      }
    });

    return results.map(r => ({
      id: r.id,
      sourceType: r.sourceType,
      sourceId: r.sourceId,
      content: r.content,
      similarity: r.similarity,
      metadata: r.metadata
    }));
  }

  async findSimilarMessages(
    messageId: string,
    options: Partial<RetrievalOptions> = {}
  ): Promise<RetrievalResult[]> {
    // Get original message embedding
    const message = await this.vectorStore.getById(messageId);
    if (!message) {
      throw new NotFoundError(`Message ${messageId} not found`);
    }

    // Search for similar messages
    const results = await this.vectorStore.search(message.embedding, {
      limit: options.limit || 5,
      threshold: options.threshold || 0.8,
      filter: {
        sourceTypes: ['message'],
        ...options
      }
    });

    // Exclude the original message
    return results.filter(r => r.id !== messageId);
  }

  async getConversationContext(
    conversationId: string,
    query: string
  ): Promise<RetrievalResult[]> {
    // Get most relevant messages from this conversation
    return this.search(query, {
      conversationId,
      sourceTypes: ['message'],
      limit: 5,
      threshold: 0.6
    });
  }

  async getBusinessContext(businessId: string): Promise<RetrievalResult | null> {
    const results = await this.vectorStore.search([], {
      limit: 1,
      filter: {
        sourceTypes: ['business_context'],
        businessId
      }
    });

    return results[0] || null;
  }

  async hybridSearch(
    query: string,
    options: RetrievalOptions = {}
  ): Promise<RetrievalResult[]> {
    // Semantic search
    const semanticResults = await this.search(query, options);

    // Keyword search (fallback)
    const keywordResults = await this.keywordSearch(query, options);

    // Merge and deduplicate
    const merged = this.mergeResults(semanticResults, keywordResults);

    return merged.slice(0, options.limit || 10);
  }

  private async keywordSearch(
    query: string,
    options: RetrievalOptions
  ): Promise<RetrievalResult[]> {
    // Simple keyword matching for fallback
    const allResults = await this.vectorStore.searchByKeyword(query, options);
    return allResults;
  }

  private mergeResults(
    semantic: RetrievalResult[],
    keyword: RetrievalResult[]
  ): RetrievalResult[] {
    const seen = new Set<string>();
    const merged: RetrievalResult[] = [];

    // Semantic results have priority
    for (const result of semantic) {
      if (!seen.has(result.id)) {
        merged.push(result);
        seen.add(result.id);
      }
    }

    // Add keyword results not already included
    for (const result of keyword) {
      if (!seen.has(result.id)) {
        merged.push({ ...result, similarity: result.similarity * 0.8 }); // Lower weight
        seen.add(result.id);
      }
    }

    // Sort by similarity
    return merged.sort((a, b) => b.similarity - a.similarity);
  }
}
```

### Context-Aware Retrieval

```typescript
// src/core/intelligence/context-retrieval.service.ts
export class ContextRetrievalService {
  constructor(
    private retrieval: RetrievalService,
    private businessRepo: BusinessRepository,
    private conversationRepo: ConversationRepository
  ) {}

  async getRelevantContext(
    currentMessage: string,
    conversationId: string
  ): Promise<string> {
    const conversation = await this.conversationRepo.findById(conversationId);
    if (!conversation) {
      throw new NotFoundError('Conversation not found');
    }

    const businessId = conversation.business_id;

    // Get business context
    const businessContext = await this.retrieval.getBusinessContext(businessId);

    // Get relevant past messages (across all conversations)
    const relevantMessages = await this.retrieval.search(currentMessage, {
      businessId,
      sourceTypes: ['message'],
      limit: 5,
      threshold: 0.75
    });

    // Get conversation-specific context
    const conversationContext = await this.retrieval.getConversationContext(
      conversationId,
      currentMessage
    );

    // Format as context string
    return this.formatContext({
      businessContext,
      relevantMessages,
      conversationContext
    });
  }

  private formatContext(data: {
    businessContext: RetrievalResult | null;
    relevantMessages: RetrievalResult[];
    conversationContext: RetrievalResult[];
  }): string {
    const sections: string[] = [];

    if (data.businessContext) {
      sections.push('## Business Context');
      sections.push(data.businessContext.content);
    }

    if (data.relevantMessages.length > 0) {
      sections.push('\n## Relevant Past Discussions');
      for (const msg of data.relevantMessages) {
        sections.push(`- ${msg.content.slice(0, 200)}... (similarity: ${msg.similarity.toFixed(2)})`);
      }
    }

    if (data.conversationContext.length > 0) {
      sections.push('\n## From This Conversation');
      for (const msg of data.conversationContext) {
        sections.push(`- ${msg.content.slice(0, 150)}...`);
      }
    }

    return sections.join('\n');
  }
}
```

### CLI Search Command

```typescript
// src/cli/commands/search.command.ts
export async function searchCommand(query: string, options: any) {
  const retrievalService = container.resolve<RetrievalService>('RetrievalService');

  const results = await retrievalService.hybridSearch(query, {
    limit: options.limit || 10,
    threshold: options.threshold || 0.7,
    businessId: options.business,
    conversationId: options.conversation
  });

  console.log(chalk.bold(`\nSearch results for: "${query}"\n`));

  for (const result of results) {
    console.log(chalk.blue(`[${result.sourceType}] ${result.content.slice(0, 100)}...`));
    console.log(chalk.gray(`  Similarity: ${(result.similarity * 100).toFixed(1)}%`));
    console.log(chalk.gray(`  ID: ${result.sourceId}\n`));
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create RetrievalService | 45 min |
| Implement semantic search | 30 min |
| Add hybrid search | 30 min |
| Create ContextRetrievalService | 45 min |
| Add /search CLI command | 20 min |
| Optimize query performance | 30 min |
| Write tests | 30 min |

---

## Acceptance Criteria
- [ ] Semantic search finds relevant messages
- [ ] Hybrid search combines semantic + keyword
- [ ] Filter by business/conversation works
- [ ] Search returns ranked results
- [ ] /search command works in CLI
- [ ] Performance < 200ms for 10K vectors

---

## Performance Optimization

**Vector Index**: sqlite-vec uses HNSW (Hierarchical Navigable Small World) for fast approximate nearest neighbor search.

**Expected Performance**:
- 10K vectors: ~50ms
- 100K vectors: ~150ms
- 1M vectors: ~500ms (requires optimization)

**Optimization Strategies**:
1. Limit search scope with filters (businessId, conversationId)
2. Use lower precision for HNSW (M=16, ef_construction=100)
3. Cache frequent queries
4. Periodically rebuild index for optimal structure
