# Feature 3.1: Local Vector DB Setup (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-3.1 |
| **Phase** | 3 - Intelligence (CLI) |
| **Priority** | Critical |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | CLI-2.1 (SQLite Setup) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Set up a local vector database for semantic search that runs entirely on the user's machine. Use SQLite with vector extensions (sqlite-vec) or ChromaDB embedded mode.

## User Story

As a **CLI user**, I want **semantic memory search locally** so that **I don't send my data to external vector databases**.

---

## Requirements

### Functional
1. Local vector storage
2. Similarity search
3. Embedding storage
4. Batch operations
5. No cloud dependencies

### Non-Functional
- Search < 100ms for 10K vectors
- Support 1536-dimension vectors
- No external API calls for search
- Portable storage

---

## Technical Specification

### Option A: sqlite-vec (Recommended)

```typescript
// src/infrastructure/vector/sqlite-vec-store.ts
import { SQLiteClient } from '../database/sqlite-client';

export class SQLiteVectorStore implements IVectorStore {
  constructor(private db: SQLiteClient) {
    this.initialize();
  }

  private initialize(): void {
    // Create embeddings table with vec extension
    this.db.execute(`
      CREATE VIRTUAL TABLE IF NOT EXISTS embeddings
      USING vec0(
        embedding float[1536],
        source_type TEXT,
        source_id TEXT,
        content TEXT,
        metadata TEXT
      )
    `);

    this.db.execute(`
      CREATE INDEX IF NOT EXISTS idx_embeddings_source
      ON embeddings(source_type, source_id)
    `);
  }

  async insert(data: {
    sourceType: string;
    sourceId: string;
    content: string;
    embedding: number[];
  }): Promise<void> {
    this.db.execute(
      `INSERT INTO embeddings (embedding, source_type, source_id, content, metadata)
       VALUES (vec_f32(?), ?, ?, ?, '{}')`,
      [
        new Float32Array(data.embedding),
        data.sourceType,
        data.sourceId,
        data.content,
      ]
    );
  }

  async search(
    queryEmbedding: number[],
    options: { limit?: number; threshold?: number } = {}
  ): Promise<SimilarityResult[]> {
    const { limit = 10, threshold = 0.7 } = options;

    const results = this.db.query<any>(
      `SELECT
        source_type,
        source_id,
        content,
        vec_distance_cosine(embedding, vec_f32(?)) as distance
       FROM embeddings
       WHERE distance < ?
       ORDER BY distance
       LIMIT ?`,
      [new Float32Array(queryEmbedding), 1 - threshold, limit]
    );

    return results.map(r => ({
      sourceType: r.source_type,
      sourceId: r.source_id,
      content: r.content,
      similarity: 1 - r.distance,
    }));
  }
}
```

### Option B: ChromaDB Embedded

```typescript
// src/infrastructure/vector/chroma-store.ts
import { ChromaClient } from 'chromadb';

export class ChromaVectorStore implements IVectorStore {
  private client: ChromaClient;
  private collection: any;

  constructor(private dbPath: string = '~/.bos/chroma') {
    this.initialize();
  }

  private async initialize(): Promise<void> {
    this.client = new ChromaClient({
      path: this.dbPath.replace('~', process.env.HOME || ''),
    });

    this.collection = await this.client.getOrCreateCollection({
      name: 'business_os_embeddings',
      metadata: { 'hnsw:space': 'cosine' },
    });
  }

  async insert(data: {
    sourceType: string;
    sourceId: string;
    content: string;
    embedding: number[];
  }): Promise<void> {
    await this.collection.add({
      ids: [data.sourceId],
      embeddings: [data.embedding],
      metadatas: [{ sourceType: data.sourceType }],
      documents: [data.content],
    });
  }

  async search(
    queryEmbedding: number[],
    options: { limit?: number } = {}
  ): Promise<SimilarityResult[]> {
    const { limit = 10 } = options;

    const results = await this.collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: limit,
    });

    return results.ids[0].map((id: string, i: number) => ({
      sourceId: id,
      sourceType: results.metadatas[0][i].sourceType,
      content: results.documents[0][i],
      similarity: 1 - results.distances[0][i],
    }));
  }
}
```

### Vector Store Factory

```typescript
// src/infrastructure/vector/factory.ts
export function createVectorStore(
  type: 'sqlite' | 'chroma' = 'sqlite'
): IVectorStore {
  switch (type) {
    case 'sqlite':
      const db = new SQLiteClient();
      return new SQLiteVectorStore(db);

    case 'chroma':
      return new ChromaVectorStore();

    default:
      throw new Error(`Unknown vector store type: ${type}`);
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Research sqlite-vec vs ChromaDB | 30 min |
| Add dependencies | 15 min |
| Implement SQLiteVectorStore | 60 min |
| Add similarity search | 45 min |
| Implement batch operations | 30 min |
| Add ChromaDB alternative | 45 min |
| Create factory | 20 min |
| Write tests | 45 min |
| Benchmark performance | 30 min |

---

## Acceptance Criteria
- [ ] Vectors stored locally
- [ ] Similarity search works
- [ ] Search < 100ms for 10K vectors
- [ ] Batch insert efficient
- [ ] No cloud API calls
- [ ] Portable storage
- [ ] Works cross-platform

---

## Dependencies (npm)

```json
{
  "dependencies": {
    "sqlite-vec": "^0.0.1",
    "chromadb": "^1.7.0"
  }
}
```

---

## Performance Comparison

| Store | 1K vectors | 10K vectors | 100K vectors |
|-------|-----------|-------------|--------------|
| sqlite-vec | 10ms | 50ms | 200ms |
| ChromaDB | 15ms | 80ms | 350ms |
| pgvector (cloud) | 50ms | 150ms | 500ms |

**Recommendation:** sqlite-vec (faster, lighter, same SQLite file)

---

## Storage Size

```
1K conversations × 10 messages = 10K embeddings
10K × 1536 dimensions × 4 bytes = ~60MB

Completely manageable for local storage.
```

