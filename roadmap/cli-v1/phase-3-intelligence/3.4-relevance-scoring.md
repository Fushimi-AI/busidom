# Feature 3.4: Relevance Scoring (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-3.4 |
| **Phase** | 3 - Intelligence & Vector Search (CLI) |
| **Priority** | High |
| **Estimated Effort** | 2-3 hours |
| **Dependencies** | CLI-3.3 (Semantic Retrieval) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement intelligent relevance scoring to rank retrieved context by business stage, recency, conversation importance, and semantic similarity for optimal context selection.

## User Story

As a **CLI user**, I want **the AI to prioritize the most relevant context** so that **it gives advice appropriate to my current business stage and recent activity**.

---

## Requirements

### Functional
1. Multi-factor relevance scoring (semantic + recency + stage + importance)
2. Stage-aware scoring (prefer stage-specific advice)
3. Recency decay (recent conversations weighted higher)
4. Conversation importance detection
5. Configurable scoring weights

### Non-Functional
- Scoring computation < 50ms
- Clear scoring explanation for debugging
- Tunable weights per user preference
- Consistent scoring across sessions

---

## Technical Specification

```typescript
// src/core/intelligence/scoring.service.ts
export interface ScoringWeights {
  semantic: number;      // Base similarity score (0.4)
  recency: number;       // Time-based decay (0.3)
  stage: number;         // Stage relevance (0.2)
  importance: number;    // Conversation importance (0.1)
}

export interface ScoredResult extends RetrievalResult {
  scores: {
    semantic: number;
    recency: number;
    stage: number;
    importance: number;
    total: number;
  };
  explanation: string;
}

export class ScoringService {
  private weights: ScoringWeights = {
    semantic: 0.4,
    recency: 0.3,
    stage: 0.2,
    importance: 0.1
  };

  constructor(
    private businessRepo: BusinessRepository,
    private conversationRepo: ConversationRepository
  ) {}

  async scoreResults(
    results: RetrievalResult[],
    context: {
      currentBusinessId: string;
      currentStage: BusinessStage;
      queryTimestamp?: number;
    }
  ): Promise<ScoredResult[]> {
    const business = await this.businessRepo.findById(context.currentBusinessId);
    if (!business) {
      throw new NotFoundError('Business not found');
    }

    const scored: ScoredResult[] = [];

    for (const result of results) {
      const semanticScore = result.similarity; // Already 0-1

      const recencyScore = this.calculateRecencyScore(
        result.metadata.timestamp,
        context.queryTimestamp || Date.now() / 1000
      );

      const stageScore = await this.calculateStageScore(
        result,
        context.currentStage
      );

      const importanceScore = await this.calculateImportanceScore(result);

      const totalScore =
        this.weights.semantic * semanticScore +
        this.weights.recency * recencyScore +
        this.weights.stage * stageScore +
        this.weights.importance * importanceScore;

      scored.push({
        ...result,
        scores: {
          semantic: semanticScore,
          recency: recencyScore,
          stage: stageScore,
          importance: importanceScore,
          total: totalScore
        },
        explanation: this.explainScore({
          semantic: semanticScore,
          recency: recencyScore,
          stage: stageScore,
          importance: importanceScore,
          total: totalScore
        })
      });
    }

    // Sort by total score descending
    return scored.sort((a, b) => b.scores.total - a.scores.total);
  }

  private calculateRecencyScore(
    itemTimestamp: number,
    currentTimestamp: number
  ): number {
    // Exponential decay: score = e^(-λt)
    // Half-life of 30 days
    const HALF_LIFE_DAYS = 30;
    const SECONDS_PER_DAY = 86400;

    const ageInDays = (currentTimestamp - itemTimestamp) / SECONDS_PER_DAY;
    const lambda = Math.log(2) / HALF_LIFE_DAYS;

    return Math.exp(-lambda * ageInDays);
  }

  private async calculateStageScore(
    result: RetrievalResult,
    currentStage: BusinessStage
  ): Promise<number> {
    // If result is from business context, always highly relevant
    if (result.sourceType === 'business_context') {
      return 1.0;
    }

    // For messages, check if they were from same stage
    if (result.sourceType === 'message' && result.metadata.conversationId) {
      const conversation = await this.conversationRepo.findById(
        result.metadata.conversationId
      );

      if (conversation) {
        const business = await this.businessRepo.findById(conversation.business_id);

        if (business) {
          // Extract stage from metadata or infer from timestamp
          const messageStage = this.inferStage(business, result.metadata.timestamp);

          if (messageStage === currentStage) {
            return 1.0; // Same stage: perfect match
          } else if (this.isAdjacentStage(messageStage, currentStage)) {
            return 0.7; // Adjacent stage: somewhat relevant
          } else {
            return 0.3; // Different stage: less relevant
          }
        }
      }
    }

    return 0.5; // Default: moderate relevance
  }

  private inferStage(business: Business, timestamp: number): BusinessStage {
    // Simple heuristic: assume linear progression through stages
    const stageOrder: BusinessStage[] = ['idea', 'validation', 'mvp', 'growth', 'scale'];
    const businessAge = timestamp - business.created_at;
    const DAYS_PER_STAGE = 90 * 86400; // 90 days per stage

    const stageIndex = Math.min(
      Math.floor(businessAge / DAYS_PER_STAGE),
      stageOrder.length - 1
    );

    return stageOrder[stageIndex];
  }

  private isAdjacentStage(stage1: BusinessStage, stage2: BusinessStage): boolean {
    const stageOrder: BusinessStage[] = ['idea', 'validation', 'mvp', 'growth', 'scale'];
    const idx1 = stageOrder.indexOf(stage1);
    const idx2 = stageOrder.indexOf(stage2);

    return Math.abs(idx1 - idx2) === 1;
  }

  private async calculateImportanceScore(result: RetrievalResult): Promise<number> {
    // Importance indicators:
    // 1. Message length (longer = more detailed)
    // 2. Keywords (decision, milestone, pivot, launch, etc.)
    // 3. Conversation activity (messages in same conversation)

    let score = 0.5; // Base importance

    // Length score
    const length = result.content.length;
    if (length > 500) score += 0.2;
    if (length > 1000) score += 0.1;

    // Keyword detection
    const importantKeywords = [
      'decision', 'milestone', 'pivot', 'launch', 'customer',
      'revenue', 'funding', 'product-market fit', 'hired', 'fired'
    ];

    const contentLower = result.content.toLowerCase();
    for (const keyword of importantKeywords) {
      if (contentLower.includes(keyword)) {
        score += 0.05; // Max +0.5 from keywords
      }
    }

    return Math.min(score, 1.0);
  }

  private explainScore(scores: ScoredResult['scores']): string {
    const parts: string[] = [];

    if (scores.semantic > 0.8) {
      parts.push('highly similar');
    } else if (scores.semantic > 0.6) {
      parts.push('somewhat similar');
    }

    if (scores.recency > 0.8) {
      parts.push('very recent');
    } else if (scores.recency > 0.5) {
      parts.push('recent');
    } else {
      parts.push('older');
    }

    if (scores.stage > 0.8) {
      parts.push('stage-appropriate');
    }

    if (scores.importance > 0.7) {
      parts.push('important discussion');
    }

    return parts.join(', ');
  }

  setWeights(weights: Partial<ScoringWeights>): void {
    this.weights = { ...this.weights, ...weights };
  }
}
```

### Integration with Retrieval

```typescript
// Update src/core/intelligence/retrieval.service.ts
export class RetrievalService {
  constructor(
    private vectorStore: IVectorStore,
    private embeddingService: EmbeddingService,
    private scoringService: ScoringService  // NEW
  ) {}

  async searchWithScoring(
    query: string,
    options: RetrievalOptions & {
      currentBusinessId: string;
      currentStage: BusinessStage;
    }
  ): Promise<ScoredResult[]> {
    // Get initial results
    const results = await this.search(query, options);

    // Apply relevance scoring
    const scored = await this.scoringService.scoreResults(results, {
      currentBusinessId: options.currentBusinessId,
      currentStage: options.currentStage,
      queryTimestamp: Date.now() / 1000
    });

    return scored;
  }
}
```

### CLI Command with Scoring

```typescript
// Update src/cli/commands/search.command.ts
export async function searchCommand(query: string, options: any) {
  const retrievalService = container.resolve<RetrievalService>('RetrievalService');
  const currentBusiness = await getCurrentBusiness();

  const results = await retrievalService.searchWithScoring(query, {
    limit: options.limit || 10,
    threshold: options.threshold || 0.7,
    currentBusinessId: currentBusiness.id,
    currentStage: currentBusiness.stage
  });

  console.log(chalk.bold(`\nSearch results for: "${query}"\n`));

  for (const result of results) {
    console.log(chalk.blue(`[${result.sourceType}] ${result.content.slice(0, 100)}...`));
    console.log(chalk.gray(`  Score: ${(result.scores.total * 100).toFixed(1)}% (${result.explanation})`));
    console.log(chalk.gray(`  Breakdown: sem=${result.scores.semantic.toFixed(2)} rec=${result.scores.recency.toFixed(2)} stage=${result.scores.stage.toFixed(2)}\n`));
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create ScoringService | 45 min |
| Implement recency decay | 20 min |
| Add stage-aware scoring | 30 min |
| Calculate importance score | 25 min |
| Integrate with retrieval | 20 min |
| Add score explanations | 15 min |
| Write tests | 25 min |

---

## Acceptance Criteria
- [ ] Multi-factor scoring works (semantic + recency + stage + importance)
- [ ] Recent messages score higher
- [ ] Stage-appropriate advice prioritized
- [ ] Important conversations detected
- [ ] Score explanations clear
- [ ] Configurable weights

---

## Scoring Examples

**Example 1: Recent, Stage-Appropriate**
- Message: "We validated our MVP with 10 customer interviews"
- Current stage: validation
- Semantic: 0.85 (query about customer validation)
- Recency: 0.95 (3 days old)
- Stage: 1.0 (same stage)
- Importance: 0.8 (contains "validated", "customer")
- **Total: 0.4×0.85 + 0.3×0.95 + 0.2×1.0 + 0.1×0.8 = 0.905**

**Example 2: Old, Different Stage**
- Message: "Brainstorming business ideas"
- Current stage: mvp
- Semantic: 0.70
- Recency: 0.20 (120 days old)
- Stage: 0.3 (idea stage vs mvp stage)
- Importance: 0.4
- **Total: 0.4×0.70 + 0.3×0.20 + 0.2×0.3 + 0.1×0.4 = 0.404**
