# Feature 5.5: Workflow CLI Commands (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-5.5 |
| **Phase** | 5 - Automation & Orchestration (CLI) |
| **Priority** | Medium |
| **Estimated Effort** | 2-3 hours |
| **Dependencies** | CLI-4.5.1 (Workflow Engine), CLI-4.5.2 (Stage-Aware Workflows) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Comprehensive CLI commands for managing workflows: start, pause, resume, view status, list available workflows, and view execution history.

## User Story

As a **CLI user**, I want **intuitive workflow commands** so that **I can easily manage automated business processes from the terminal**.

---

## Requirements

### Functional
1. List available workflows (by stage)
2. Start workflow execution
3. View workflow status (in-progress)
4. Pause/resume workflows
5. View execution history
6. Interactive workflow selection

### Non-Functional
- Command response time < 100ms
- Clear, actionable output
- Colorized terminal output
- Tab completion support

---

## Technical Specification

```typescript
// src/cli/commands/workflow.command.ts
import chalk from 'chalk';
import inquirer from 'inquirer';
import { WorkflowEngine } from '@/core/automation/workflow-engine';
import { WorkflowDefinition, WorkflowExecution } from '@/core/automation/types';

export async function workflowListCommand(options: { stage?: string }) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');
  const business = await getCurrentBusiness();

  let workflows: WorkflowDefinition[];

  if (options.stage) {
    workflows = await workflowEngine.listWorkflowsByStage(options.stage as BusinessStage);
  } else {
    workflows = await workflowEngine.listWorkflows();
  }

  console.log(chalk.bold(`\nAvailable Workflows${options.stage ? ` (${options.stage} stage)` : ''}\n`));

  const grouped = groupByStage(workflows);

  for (const [stage, stageWorkflows] of Object.entries(grouped)) {
    console.log(chalk.blue(`\n${stage.toUpperCase()} Stage:`));

    for (const workflow of stageWorkflows) {
      const status = business.stage === stage ? chalk.green('(current stage)') : '';
      console.log(`  ${chalk.bold(workflow.name)} ${status}`);
      console.log(`    ${chalk.gray(workflow.description)}`);
      console.log(`    ${chalk.gray(`ID: ${workflow.id} | Steps: ${workflow.steps.length}`)}\n`);
    }
  }
}

export async function workflowStartCommand(workflowId?: string) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');
  const business = await getCurrentBusiness();

  // If no workflow ID provided, show interactive selection
  if (!workflowId) {
    const workflows = await workflowEngine.listWorkflowsByStage(business.stage);

    if (workflows.length === 0) {
      console.log(chalk.yellow(`No workflows available for ${business.stage} stage`));
      return;
    }

    const { selectedWorkflow } = await inquirer.prompt([
      {
        type: 'list',
        name: 'selectedWorkflow',
        message: 'Select a workflow to start:',
        choices: workflows.map(w => ({
          name: `${w.name} - ${w.description}`,
          value: w.id
        }))
      }
    ]);

    workflowId = selectedWorkflow;
  }

  // Start workflow
  console.log(chalk.gray(`Starting workflow: ${workflowId}...`));

  try {
    const execution = await workflowEngine.startWorkflow(workflowId, {
      businessId: business.id,
      triggeredBy: 'manual_cli',
      timestamp: Date.now()
    });

    console.log(chalk.green(`\n✓ Workflow started`));
    console.log(chalk.gray(`Execution ID: ${execution.id}`));
    console.log(chalk.gray(`Status: ${execution.status}\n`));

    // If it's an interactive workflow, start prompting
    if (execution.status === 'in_progress') {
      await interactiveWorkflowExecution(execution.id);
    }
  } catch (error) {
    console.log(chalk.red(`✗ Failed to start workflow: ${error.message}`));
  }
}

async function interactiveWorkflowExecution(executionId: string) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');

  while (true) {
    const execution = await workflowEngine.getExecution(executionId);

    if (execution.status === 'completed' || execution.status === 'failed') {
      console.log(chalk.green(`\n✓ Workflow ${execution.status}`));
      break;
    }

    const currentStep = execution.steps.find(s => s.status === 'in_progress');

    if (!currentStep) {
      // Waiting for async step
      console.log(chalk.gray('Waiting for next step...'));
      await new Promise(resolve => setTimeout(resolve, 2000));
      continue;
    }

    // Show current step
    console.log(chalk.bold(`\n${currentStep.name}`));

    if (currentStep.type === 'task') {
      console.log(chalk.gray(currentStep.description));

      const { input } = await inquirer.prompt([
        {
          type: 'input',
          name: 'input',
          message: currentStep.prompt || 'Enter your response:',
          validate: (value) => {
            if (!value) return 'Response is required';
            if (currentStep.validation?.min_length && value.length < currentStep.validation.min_length) {
              return `Minimum ${currentStep.validation.min_length} characters required`;
            }
            return true;
          }
        }
      ]);

      await workflowEngine.completeStep(executionId, currentStep.id, { input });
    } else if (currentStep.type === 'decision') {
      console.log(chalk.gray(currentStep.description));

      const { decision } = await inquirer.prompt([
        {
          type: 'list',
          name: 'decision',
          message: currentStep.prompt || 'Choose an option:',
          choices: currentStep.options.map(opt => ({
            name: opt.label,
            value: opt.value
          }))
        }
      ]);

      await workflowEngine.completeStep(executionId, currentStep.id, { decision });
    }
  }
}

export async function workflowStatusCommand(executionId?: string) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');

  if (!executionId) {
    // Show all in-progress workflows
    const executions = await workflowEngine.listExecutions({ status: 'in_progress' });

    if (executions.length === 0) {
      console.log(chalk.gray('No workflows currently running'));
      return;
    }

    console.log(chalk.bold('\nRunning Workflows\n'));

    for (const exec of executions) {
      const workflow = await workflowEngine.getWorkflowDefinition(exec.workflowId);
      const progress = `${exec.steps.filter(s => s.status === 'completed').length}/${exec.steps.length}`;

      console.log(`  ${chalk.blue(workflow.name)}`);
      console.log(`    Status: ${exec.status} | Progress: ${progress}`);
      console.log(`    Execution ID: ${chalk.gray(exec.id)}\n`);
    }

    return;
  }

  // Show specific execution
  const execution = await workflowEngine.getExecution(executionId);
  const workflow = await workflowEngine.getWorkflowDefinition(execution.workflowId);

  console.log(chalk.bold(`\nWorkflow: ${workflow.name}\n`));
  console.log(`Status: ${execution.status}`);
  console.log(`Started: ${new Date(execution.startedAt).toLocaleString()}`);

  if (execution.completedAt) {
    console.log(`Completed: ${new Date(execution.completedAt).toLocaleString()}`);
  }

  console.log(chalk.bold('\nSteps:\n'));

  for (const step of execution.steps) {
    const icon = getStatusIcon(step.status);
    console.log(`  ${icon} ${step.name} (${step.status})`);

    if (step.result) {
      console.log(`    ${chalk.gray(`Result: ${JSON.stringify(step.result).slice(0, 100)}...`)}`);
    }
  }

  console.log();
}

export async function workflowHistoryCommand(options: { limit?: number }) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');
  const business = await getCurrentBusiness();

  const executions = await workflowEngine.listExecutions({
    businessId: business.id,
    limit: options.limit || 10,
    orderBy: 'startedAt',
    order: 'desc'
  });

  console.log(chalk.bold('\nWorkflow Execution History\n'));

  if (executions.length === 0) {
    console.log(chalk.gray('No workflow executions found'));
    return;
  }

  for (const exec of executions) {
    const workflow = await workflowEngine.getWorkflowDefinition(exec.workflowId);
    const statusColor = exec.status === 'completed' ? chalk.green : exec.status === 'failed' ? chalk.red : chalk.yellow;
    const duration = exec.completedAt ? formatDuration(exec.completedAt - exec.startedAt) : 'in progress';

    console.log(`  ${statusColor(exec.status.toUpperCase())} | ${chalk.blue(workflow.name)}`);
    console.log(`    Started: ${new Date(exec.startedAt).toLocaleString()}`);
    console.log(`    Duration: ${duration}`);
    console.log(`    ID: ${chalk.gray(exec.id)}\n`);
  }
}

export async function workflowPauseCommand(executionId: string) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');

  await workflowEngine.pauseExecution(executionId);
  console.log(chalk.green(`✓ Workflow paused: ${executionId}`));
}

export async function workflowResumeCommand(executionId: string) {
  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');

  await workflowEngine.resumeExecution(executionId);
  console.log(chalk.green(`✓ Workflow resumed: ${executionId}`));

  // Continue interactive execution
  await interactiveWorkflowExecution(executionId);
}

export async function workflowCancelCommand(executionId: string) {
  const { confirm } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'confirm',
      message: 'Are you sure you want to cancel this workflow?',
      default: false
    }
  ]);

  if (!confirm) {
    console.log(chalk.gray('Cancelled'));
    return;
  }

  const workflowEngine = container.resolve<WorkflowEngine>('WorkflowEngine');

  await workflowEngine.cancelExecution(executionId);
  console.log(chalk.green(`✓ Workflow cancelled: ${executionId}`));
}

// Helper functions
function groupByStage(workflows: WorkflowDefinition[]): Record<string, WorkflowDefinition[]> {
  return workflows.reduce((acc, w) => {
    const stage = w.metadata?.stage || 'all';
    if (!acc[stage]) acc[stage] = [];
    acc[stage].push(w);
    return acc;
  }, {} as Record<string, WorkflowDefinition[]>);
}

function getStatusIcon(status: string): string {
  switch (status) {
    case 'completed': return chalk.green('✓');
    case 'failed': return chalk.red('✗');
    case 'in_progress': return chalk.yellow('→');
    case 'pending': return chalk.gray('○');
    default: return '?';
  }
}

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) return `${hours}h ${minutes % 60}m`;
  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
  return `${seconds}s`;
}
```

### Command Registration

```typescript
// src/cli/index.ts
import { Command } from 'commander';

const program = new Command();

// Workflow commands
const workflow = program.command('workflow').alias('wf').description('Manage workflows');

workflow
  .command('list')
  .option('-s, --stage <stage>', 'Filter by stage')
  .description('List available workflows')
  .action(workflowListCommand);

workflow
  .command('start [workflow-id]')
  .description('Start a workflow (interactive if no ID provided)')
  .action(workflowStartCommand);

workflow
  .command('status [execution-id]')
  .description('View workflow status')
  .action(workflowStatusCommand);

workflow
  .command('history')
  .option('-l, --limit <number>', 'Number of executions to show', '10')
  .description('View workflow execution history')
  .action(workflowHistoryCommand);

workflow
  .command('pause <execution-id>')
  .description('Pause a running workflow')
  .action(workflowPauseCommand);

workflow
  .command('resume <execution-id>')
  .description('Resume a paused workflow')
  .action(workflowResumeCommand);

workflow
  .command('cancel <execution-id>')
  .description('Cancel a running workflow')
  .action(workflowCancelCommand);
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create workflow CLI commands | 45 min |
| Implement interactive workflow | 45 min |
| Add list/status commands | 30 min |
| Add pause/resume commands | 20 min |
| Implement history display | 20 min |
| Add command registration | 15 min |
| Write tests | 25 min |

---

## Acceptance Criteria
- [ ] /workflow list shows available workflows
- [ ] /workflow start launches workflow
- [ ] Interactive workflow execution works
- [ ] /workflow status shows progress
- [ ] /workflow history displays past executions
- [ ] Pause/resume functionality works
- [ ] Clear, colorized output

---

## CLI Commands

```bash
bos workflow list                    # List all workflows
bos workflow list --stage validation # Filter by stage
bos workflow start                   # Interactive selection
bos workflow start <workflow-id>     # Start specific workflow
bos workflow status                  # Show running workflows
bos workflow status <execution-id>   # Show specific execution
bos workflow history                 # Last 10 executions
bos workflow history --limit 50      # Custom limit
bos workflow pause <execution-id>    # Pause workflow
bos workflow resume <execution-id>   # Resume workflow
bos workflow cancel <execution-id>   # Cancel workflow

# Aliases
bos wf list
bos wf start
```

---

## Dependencies

```json
{
  "inquirer": "^9.2.0",
  "chalk": "^4.1.2",
  "commander": "^11.0.0"
}
```

---

## Example Output

```
$ bos workflow list --stage validation

Available Workflows (validation stage)

VALIDATION Stage:
  Customer Validation (current stage)
    Guide through customer interview process
    ID: customer_validation_idea_stage | Steps: 5

  Problem Validation
    Validate problem-solution fit
    ID: problem_validation | Steps: 4

$ bos workflow start

? Select a workflow to start: Customer Validation - Guide through customer interview process

Starting workflow: customer_validation_idea_stage...

✓ Workflow started
Execution ID: wf_exec_abc123
Status: in_progress

Step 1: Identify Core Problem

Enter the main problem your business solves (minimum 50 characters):
> [user input]
```
