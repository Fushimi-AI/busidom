# Feature 5.3: CLI Automation Scheduler (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-5.3 |
| **Phase** | 5 - Automation & Orchestration (CLI) |
| **Priority** | High |
| **Estimated Effort** | 3-4 hours |
| **Dependencies** | CLI-4.5.1 (Workflow Engine), CLI-4.5.3 (Automation Scheduler Core), 5.6 (Proactive Accountability), 5.7 (Monitoring Engine) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement local cron-based automation scheduler for CLI that runs in the background as a daemon process, executing recurring tasks like daily briefs, weekly reviews, automated workflows, **proactive accountability check-ins, and background monitoring**.

**Enhanced with Ambient Computing**: Scheduler now includes proactive patterns - commitment follow-ups, monitoring tasks, and intelligent check-ins that anticipate user needs.

## User Story

As a **CLI user**, I want **automated tasks to run in the background** so that **I get daily briefs, weekly reviews, and proactive check-ins without manual intervention**.

---

## Requirements

### Functional
1. Background daemon process management
2. Local cron job scheduling (node-cron)
3. Process persistence across restarts
4. Job execution logging
5. Manual job trigger capability
6. Health monitoring
7. **Proactive follow-up scheduling (commitment check-ins)**
8. **Background monitoring task execution**
9. **Dynamic job creation (auto-schedule based on events)**

### Non-Functional
- Daemon startup < 2 seconds
- Low resource usage (< 50MB RAM idle)
- Reliable execution (99.9% job success rate)
- Graceful shutdown
- Cross-platform (macOS, Linux, Windows)

---

## Technical Specification

```typescript
// src/cli/scheduler/daemon.ts
import cron from 'node-cron';
import { SchedulerService } from '@/core/automation/scheduler.service';
import { WorkflowEngine } from '@/core/automation/workflow-engine';
import fs from 'fs/promises';
import path from 'path';

export interface DaemonConfig {
  pidFile: string;
  logFile: string;
  jobs: ScheduledJob[];
}

export interface ScheduledJob {
  id: string;
  name: string;
  schedule: string; // Cron format
  workflowId: string;
  enabled: boolean;
}

export class SchedulerDaemon {
  private jobs: Map<string, cron.ScheduledTask> = new Map();
  private isRunning = false;
  private readonly PID_FILE: string;
  private readonly LOG_FILE: string;

  constructor(
    private config: DaemonConfig,
    private schedulerService: SchedulerService,
    private workflowEngine: WorkflowEngine
  ) {
    this.PID_FILE = config.pidFile || path.join(os.homedir(), '.busidom', 'scheduler.pid');
    this.LOG_FILE = config.logFile || path.join(os.homedir(), '.busidom', 'scheduler.log');
  }

  async start(): Promise<void> {
    // Check if already running
    if (await this.isAlreadyRunning()) {
      throw new Error('Scheduler daemon is already running');
    }

    // Write PID file
    await fs.writeFile(this.PID_FILE, process.pid.toString());

    // Register shutdown handlers
    process.on('SIGINT', () => this.shutdown());
    process.on('SIGTERM', () => this.shutdown());

    // Load jobs from config
    await this.loadJobs();

    // Start all enabled jobs
    for (const [jobId, task] of this.jobs) {
      task.start();
      await this.log(`Started job: ${jobId}`);
    }

    this.isRunning = true;
    await this.log('Scheduler daemon started');

    // Keep process alive
    process.stdin.resume();
  }

  async loadJobs(): Promise<void> {
    const jobs = this.config.jobs;

    for (const job of jobs) {
      if (!job.enabled) continue;

      const task = cron.schedule(job.schedule, async () => {
        await this.executeJob(job);
      });

      this.jobs.set(job.id, task);
      await this.log(`Loaded job: ${job.name} (${job.schedule})`);
    }
  }

  private async executeJob(job: ScheduledJob): Promise<void> {
    await this.log(`Executing job: ${job.name}`);

    try {
      const result = await this.workflowEngine.execute(job.workflowId, {
        triggeredBy: 'scheduler',
        jobId: job.id,
        timestamp: Date.now()
      });

      await this.log(`Job completed: ${job.name} (status: ${result.status})`);
    } catch (error) {
      await this.log(`Job failed: ${job.name} - ${error.message}`, 'error');
    }
  }

  async addJob(job: ScheduledJob): Promise<void> {
    if (this.jobs.has(job.id)) {
      throw new Error(`Job ${job.id} already exists`);
    }

    const task = cron.schedule(job.schedule, async () => {
      await this.executeJob(job);
    });

    this.jobs.set(job.id, task);

    if (job.enabled && this.isRunning) {
      task.start();
    }

    // Persist to config
    this.config.jobs.push(job);
    await this.saveConfig();

    await this.log(`Added job: ${job.name}`);
  }

  async removeJob(jobId: string): Promise<void> {
    const task = this.jobs.get(jobId);
    if (!task) {
      throw new Error(`Job ${jobId} not found`);
    }

    task.stop();
    this.jobs.delete(jobId);

    // Remove from config
    this.config.jobs = this.config.jobs.filter(j => j.id !== jobId);
    await this.saveConfig();

    await this.log(`Removed job: ${jobId}`);
  }

  async listJobs(): Promise<ScheduledJob[]> {
    return this.config.jobs;
  }

  async triggerJob(jobId: string): Promise<void> {
    const job = this.config.jobs.find(j => j.id === jobId);
    if (!job) {
      throw new Error(`Job ${jobId} not found`);
    }

    await this.log(`Manually triggering job: ${job.name}`);
    await this.executeJob(job);
  }

  async shutdown(): Promise<void> {
    if (!this.isRunning) return;

    await this.log('Shutting down scheduler daemon...');

    // Stop all jobs
    for (const [jobId, task] of this.jobs) {
      task.stop();
      await this.log(`Stopped job: ${jobId}`);
    }

    // Remove PID file
    try {
      await fs.unlink(this.PID_FILE);
    } catch (error) {
      // Ignore if file doesn't exist
    }

    this.isRunning = false;
    await this.log('Scheduler daemon stopped');

    process.exit(0);
  }

  private async isAlreadyRunning(): Promise<boolean> {
    try {
      const pidStr = await fs.readFile(this.PID_FILE, 'utf-8');
      const pid = parseInt(pidStr, 10);

      // Check if process is still running
      try {
        process.kill(pid, 0); // Signal 0 checks existence
        return true;
      } catch {
        // Process not running, remove stale PID file
        await fs.unlink(this.PID_FILE);
        return false;
      }
    } catch {
      return false;
    }
  }

  private async saveConfig(): Promise<void> {
    const configPath = path.join(os.homedir(), '.busidom', 'scheduler-config.json');
    await fs.writeFile(configPath, JSON.stringify(this.config, null, 2));
  }

  private async log(message: string, level: 'info' | 'error' = 'info'): Promise<void> {
    const timestamp = new Date().toISOString();
    const logLine = `[${timestamp}] [${level.toUpperCase()}] ${message}\n`;

    await fs.appendFile(this.LOG_FILE, logLine);

    if (level === 'error') {
      console.error(logLine);
    }
  }
}
```

### CLI Daemon Commands

```typescript
// src/cli/commands/scheduler.command.ts
import { SchedulerDaemon } from '../scheduler/daemon';
import chalk from 'chalk';
import { spawn } from 'child_process';

export async function schedulerStartCommand() {
  // Start daemon in background
  const daemon = spawn('node', [
    path.join(__dirname, '../scheduler/daemon-process.js')
  ], {
    detached: true,
    stdio: 'ignore'
  });

  daemon.unref();

  console.log(chalk.green('✓ Scheduler daemon started'));
}

export async function schedulerStopCommand() {
  const pidFile = path.join(os.homedir(), '.busidom', 'scheduler.pid');

  try {
    const pidStr = await fs.readFile(pidFile, 'utf-8');
    const pid = parseInt(pidStr, 10);

    process.kill(pid, 'SIGTERM');

    console.log(chalk.green('✓ Scheduler daemon stopped'));
  } catch (error) {
    console.log(chalk.yellow('Scheduler daemon is not running'));
  }
}

export async function schedulerStatusCommand() {
  const daemon = await getDaemon();

  if (!daemon) {
    console.log(chalk.yellow('Scheduler daemon is not running'));
    return;
  }

  const jobs = await daemon.listJobs();

  console.log(chalk.bold('\nScheduler Status\n'));
  console.log(chalk.green('Status: Running'));
  console.log(chalk.gray(`PID: ${await getPid()}\n`));

  console.log(chalk.bold('Scheduled Jobs:\n'));

  for (const job of jobs) {
    const status = job.enabled ? chalk.green('enabled') : chalk.gray('disabled');
    console.log(`  ${chalk.blue(job.name)} (${status})`);
    console.log(`    Schedule: ${job.schedule}`);
    console.log(`    Workflow: ${job.workflowId}\n`);
  }
}

export async function schedulerListCommand() {
  const daemon = await getDaemon();

  if (!daemon) {
    console.log(chalk.yellow('Scheduler daemon is not running'));
    return;
  }

  const jobs = await daemon.listJobs();

  console.log(chalk.bold('\nScheduled Jobs\n'));

  if (jobs.length === 0) {
    console.log(chalk.gray('No jobs scheduled'));
    return;
  }

  for (const job of jobs) {
    console.log(chalk.blue(`${job.name} (${job.id})`));
    console.log(`  Schedule: ${job.schedule}`);
    console.log(`  Enabled: ${job.enabled ? 'yes' : 'no'}`);
    console.log(`  Workflow: ${job.workflowId}\n`);
  }
}

export async function schedulerTriggerCommand(jobId: string) {
  const daemon = await getDaemon();

  if (!daemon) {
    console.log(chalk.yellow('Scheduler daemon is not running. Start it with: busidom scheduler start'));
    return;
  }

  await daemon.triggerJob(jobId);
  console.log(chalk.green(`✓ Triggered job: ${jobId}`));
}

export async function schedulerAddCommand(options: {
  name: string;
  schedule: string;
  workflow: string;
}) {
  const daemon = await getDaemon();

  if (!daemon) {
    console.log(chalk.yellow('Scheduler daemon is not running. Start it with: busidom scheduler start'));
    return;
  }

  await daemon.addJob({
    id: generateId(),
    name: options.name,
    schedule: options.schedule,
    workflowId: options.workflow,
    enabled: true
  });

  console.log(chalk.green(`✓ Added job: ${options.name}`));
}

async function getDaemon(): Promise<SchedulerDaemon | null> {
  // Connect to running daemon via IPC or HTTP
  // For simplicity, read PID and check if running
  try {
    const pidFile = path.join(os.homedir(), '.busidom', 'scheduler.pid');
    const pidStr = await fs.readFile(pidFile, 'utf-8');
    const pid = parseInt(pidStr, 10);

    process.kill(pid, 0); // Check if running

    // Return daemon client (implement IPC/HTTP connection)
    return null; // Placeholder
  } catch {
    return null;
  }
}
```

### Default Jobs Configuration

```typescript
// src/cli/scheduler/default-jobs.ts
export const DEFAULT_JOBS: ScheduledJob[] = [
  {
    id: 'daily-brief',
    name: 'Daily Business Brief',
    schedule: '0 9 * * *', // 9 AM daily
    workflowId: 'daily_brief',
    enabled: true
  },
  {
    id: 'weekly-review',
    name: 'Weekly Progress Review',
    schedule: '0 18 * * 5', // 6 PM every Friday
    workflowId: 'weekly_review',
    enabled: true
  },
  {
    id: 'monthly-metrics',
    name: 'Monthly Metrics Summary',
    schedule: '0 10 1 * *', // 10 AM on 1st of each month
    workflowId: 'monthly_metrics',
    enabled: false
  }
];
```

---

### Integration with Proactive Accountability System

The scheduler now dynamically schedules commitment follow-ups based on Feature 5.6 (Proactive Accountability):

```typescript
// src/cli/scheduler/accountability-integration.ts
import { AccountabilityService } from '@/core/accountability/accountability.service';
import { SchedulerDaemon } from './daemon';

export class AccountabilitySchedulerIntegration {
  constructor(
    private scheduler: SchedulerDaemon,
    private accountabilityService: AccountabilityService
  ) {
    // Listen for new commitments
    this.accountabilityService.on('commitment:created', this.onCommitmentCreated.bind(this));
  }

  private async onCommitmentCreated(commitment: Commitment): Promise<void> {
    // Schedule follow-ups for this commitment
    for (const followUp of commitment.followUps) {
      await this.scheduleFollowUp(commitment, followUp);
    }
  }

  private async scheduleFollowUp(
    commitment: Commitment,
    followUp: FollowUp
  ): Promise<void> {
    // Convert Date to cron schedule (run once at specific time)
    const cronSchedule = this.dateToCron(followUp.scheduledFor);

    const jobId = `followup-${commitment.id}-${followUp.id}`;

    await this.scheduler.addJob({
      id: jobId,
      name: `Follow-up: ${commitment.parsedGoal}`,
      schedule: cronSchedule,
      workflowId: 'commitment_followup',
      enabled: true,
      metadata: {
        commitmentId: commitment.id,
        followUpId: followUp.id,
        type: 'accountability_followup'
      }
    });

    console.log(`[Scheduler] Scheduled follow-up for: ${commitment.parsedGoal} at ${followUp.scheduledFor}`);
  }

  private dateToCron(date: Date): string {
    // Convert specific date to cron format
    // Note: node-cron doesn't support one-time jobs, so we'll use a workaround
    // Run at specific minute, hour, day, month
    const minute = date.getMinutes();
    const hour = date.getHours();
    const dayOfMonth = date.getDate();
    const month = date.getMonth() + 1;

    return `${minute} ${hour} ${dayOfMonth} ${month} *`;
  }
}
```

**Accountability Job Example**:
When a user commits "I'll talk to 10 customers this week", the scheduler automatically creates jobs like:
- **Early check-in**: 3 days from now
- **Deadline check-in**: 7 days from now (end of week)
- **Overdue check-in**: 8 days from now

---

### Integration with Always-On Monitoring Engine

The scheduler executes monitoring tasks from Feature 5.7 (Always-On Monitoring):

```typescript
// src/cli/scheduler/monitoring-integration.ts
import { MonitoringEngine } from '@/core/monitoring/monitoring.engine';
import { SchedulerDaemon } from './daemon';

export class MonitoringSchedulerIntegration {
  constructor(
    private scheduler: SchedulerDaemon,
    private monitoringEngine: MonitoringEngine
  ) {
    // Listen for new monitors
    this.monitoringEngine.on('monitor:added', this.onMonitorAdded.bind(this));
    this.monitoringEngine.on('monitor:removed', this.onMonitorRemoved.bind(this));
  }

  private async onMonitorAdded(monitor: MonitorTask): Promise<void> {
    // Convert monitoring interval to cron schedule
    const cronSchedule = this.intervalToCron(monitor.schedule.interval);

    const jobId = `monitor-${monitor.id}`;

    await this.scheduler.addJob({
      id: jobId,
      name: `Monitor: ${monitor.name}`,
      schedule: cronSchedule,
      workflowId: 'monitoring_task',
      enabled: monitor.status === 'active',
      metadata: {
        monitorId: monitor.id,
        type: 'monitoring_task'
      }
    });

    console.log(`[Scheduler] Scheduled monitor: ${monitor.name} (every ${monitor.schedule.interval} min)`);
  }

  private async onMonitorRemoved(monitorId: string): Promise<void> {
    const jobId = `monitor-${monitorId}`;
    await this.scheduler.removeJob(jobId);

    console.log(`[Scheduler] Removed monitor job: ${monitorId}`);
  }

  private intervalToCron(minutes: number): string {
    // Convert interval in minutes to cron schedule
    if (minutes < 60) {
      // Every N minutes
      return `*/${minutes} * * * *`;
    } else if (minutes < 1440) {
      // Every N hours
      const hours = Math.floor(minutes / 60);
      return `0 */${hours} * * *`;
    } else {
      // Every N days
      const days = Math.floor(minutes / 1440);
      return `0 0 */${days} * *`;
    }
  }

  private applyActiveHours(cronSchedule: string, activeHours?: { start: number; end: number }): string {
    if (!activeHours) return cronSchedule;

    // Modify cron to only run during active hours
    // Example: "0 9-17 * * *" runs hourly from 9 AM to 5 PM
    const parts = cronSchedule.split(' ');
    parts[1] = `${activeHours.start}-${activeHours.end}`;

    return parts.join(' ');
  }
}
```

**Monitoring Job Examples**:
- **Competitor pricing**: Every 6 hours (0 */6 * * *)
- **Social mentions**: Every 30 minutes (*/30 * * * *)
- **Market data**: Daily at 10 AM (0 10 * * *)

---

### Enhanced Daemon with Proactive Patterns

Update the SchedulerDaemon to support dynamic job metadata and one-time jobs:

```typescript
// Enhancement to SchedulerDaemon
export interface ScheduledJob {
  id: string;
  name: string;
  schedule: string;       // Cron format
  workflowId: string;
  enabled: boolean;
  metadata?: {            // NEW: Additional context
    type?: 'workflow' | 'accountability_followup' | 'monitoring_task';
    commitmentId?: string;
    followUpId?: string;
    monitorId?: string;
  };
  oneTime?: boolean;      // NEW: Auto-remove after execution
}

// In executeJob method, add:
private async executeJob(job: ScheduledJob): Promise<void> {
  await this.log(`Executing job: ${job.name}`);

  try {
    const result = await this.workflowEngine.execute(job.workflowId, {
      triggeredBy: 'scheduler',
      jobId: job.id,
      timestamp: Date.now(),
      ...job.metadata  // Pass metadata to workflow
    });

    await this.log(`Job completed: ${job.name} (status: ${result.status})`);

    // NEW: Remove one-time jobs after execution
    if (job.oneTime) {
      await this.removeJob(job.id);
      await this.log(`Removed one-time job: ${job.id}`);
    }

  } catch (error) {
    await this.log(`Job failed: ${job.name} - ${error.message}`, 'error');
  }
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Create SchedulerDaemon | 60 min |
| Implement job management | 30 min |
| Add daemon process lifecycle | 45 min |
| Create CLI commands | 30 min |
| Add default jobs | 15 min |
| Implement logging | 20 min |
| **Integrate with accountability system** | **45 min** |
| **Integrate with monitoring engine** | **45 min** |
| **Add dynamic job metadata support** | **30 min** |
| Write tests | 45 min |

---

## Acceptance Criteria
- [ ] Daemon starts in background
- [ ] Jobs execute on schedule
- [ ] Can add/remove jobs dynamically
- [ ] Manual job triggering works
- [ ] Daemon survives restarts
- [ ] /scheduler commands work
- [ ] Low resource usage (< 50MB)
- [ ] **Commitment follow-ups auto-scheduled**
- [ ] **Monitoring tasks execute on interval**
- [ ] **One-time jobs auto-remove after execution**
- [ ] **Dynamic job metadata passed to workflows**

---

## CLI Commands

```bash
busidom scheduler start           # Start daemon
busidom scheduler stop            # Stop daemon
busidom scheduler status          # Show status + jobs
busidom scheduler list            # List all jobs
busidom scheduler trigger <id>    # Manually run a job
busidom scheduler add             # Add new job (interactive)
busidom scheduler remove <id>     # Remove job
busidom scheduler logs            # View execution logs
```

---

## Dependencies

```json
{
  "node-cron": "^3.0.2"
}
```

---

## Platform-Specific Notes

**macOS/Linux**: Use standard daemon process with PID file

**Windows**: Use Windows Service or background process with different PID management

**Cross-platform**: Use `pm2` or `forever` for production-grade process management (optional)
