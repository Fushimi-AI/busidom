# Feature 2.1: SQLite Setup (CLI)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | CLI-2.1 |
| **Phase** | 2 - Local Storage (CLI) |
| **Priority** | Critical |
| **Estimated Effort** | 3-4 hours |
| **Dependencies** | 0.3 (Core Architecture) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Set up SQLite as the local database for CLI, providing full relational database capabilities that run entirely on the user's machine with zero configuration.

## User Story

As a **CLI user**, I want my **data stored locally** so that **I own my data and don't need cloud services**.

---

## Requirements

### Functional
1. SQLite database initialization
2. Migration system
3. Schema management
4. Query interface
5. Backup/restore

### Non-Functional
- No external dependencies
- Single file database (~/.bos/data.db)
- ACID transactions
- File-based, portable

---

## Technical Specification

### Database File Location

```
~/.bos/
├── config.json
├── data.db          ← SQLite database
└── data.db-wal      ← Write-ahead log (auto)
```

### Schema (Same as PostgreSQL version)

```sql
-- migrations/001_initial.sql

CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT,
  name TEXT,
  created_at INTEGER DEFAULT (unixepoch()),
  updated_at INTEGER DEFAULT (unixepoch())
);

CREATE TABLE businesses (
  id TEXT PRIMARY KEY,
  user_id TEXT REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  industry TEXT,
  stage TEXT DEFAULT 'idea',
  context TEXT DEFAULT '{}',  -- JSON stored as text
  created_at INTEGER DEFAULT (unixepoch()),
  updated_at INTEGER DEFAULT (unixepoch())
);

CREATE TABLE conversations (
  id TEXT PRIMARY KEY,
  business_id TEXT REFERENCES businesses(id) ON DELETE CASCADE,
  title TEXT,
  message_count INTEGER DEFAULT 0,
  created_at INTEGER DEFAULT (unixepoch()),
  updated_at INTEGER DEFAULT (unixepoch())
);

CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  conversation_id TEXT REFERENCES conversations(id) ON DELETE CASCADE,
  role TEXT NOT NULL,
  content TEXT NOT NULL,
  metadata TEXT DEFAULT '{}',
  created_at INTEGER DEFAULT (unixepoch())
);

CREATE INDEX idx_businesses_user_id ON businesses(user_id);
CREATE INDEX idx_conversations_business_id ON conversations(business_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

### Database Client

```typescript
// src/infrastructure/database/sqlite-client.ts
import Database from 'better-sqlite3';
import * as path from 'path';

export class SQLiteClient {
  private db: Database.Database;

  constructor(dbPath: string = '~/.bos/data.db') {
    const fullPath = dbPath.replace('~', process.env.HOME || '');
    this.db = new Database(fullPath);

    // Enable WAL mode for better concurrency
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('foreign_keys = ON');
  }

  query<T>(sql: string, params?: unknown[]): T[] {
    const stmt = this.db.prepare(sql);
    return params ? stmt.all(...params) as T[] : stmt.all() as T[];
  }

  queryOne<T>(sql: string, params?: unknown[]): T | null {
    const stmt = this.db.prepare(sql);
    const result = params ? stmt.get(...params) : stmt.get();
    return result as T | null;
  }

  execute(sql: string, params?: unknown[]): number {
    const stmt = this.db.prepare(sql);
    const result = params ? stmt.run(...params) : stmt.run();
    return result.changes;
  }

  transaction<T>(fn: () => T): T {
    const trans = this.db.transaction(fn);
    return trans();
  }

  close(): void {
    this.db.close();
  }

  backup(backupPath: string): void {
    this.db.backup(backupPath);
  }
}
```

### Migration System

```typescript
// src/infrastructure/database/sqlite-migrator.ts
import * as fs from 'fs';
import * as path from 'path';
import { SQLiteClient } from './sqlite-client';

export class SQLiteMigrator {
  constructor(
    private db: SQLiteClient,
    private migrationsPath: string
  ) {}

  async run(): Promise<void> {
    this.ensureMigrationTable();

    const applied = this.getAppliedMigrations();
    const pending = this.getPendingMigrations(applied);

    for (const migration of pending) {
      console.log(`Running migration: ${migration.name}`);
      this.applyMigration(migration);
    }
  }

  private ensureMigrationTable(): void {
    this.db.execute(`
      CREATE TABLE IF NOT EXISTS migrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        applied_at INTEGER DEFAULT (unixepoch())
      )
    `);
  }

  private getAppliedMigrations(): string[] {
    const rows = this.db.query<{ name: string }>('SELECT name FROM migrations');
    return rows.map(r => r.name);
  }

  private getPendingMigrations(applied: string[]): Migration[] {
    const files = fs.readdirSync(this.migrationsPath);
    const migrations: Migration[] = [];

    for (const file of files.sort()) {
      if (!file.endsWith('.sql')) continue;
      if (applied.includes(file)) continue;

      const sql = fs.readFileSync(
        path.join(this.migrationsPath, file),
        'utf-8'
      );

      migrations.push({ name: file, sql });
    }

    return migrations;
  }

  private applyMigration(migration: Migration): void {
    this.db.transaction(() => {
      // Split and execute multiple statements
      const statements = migration.sql
        .split(';')
        .map(s => s.trim())
        .filter(s => s.length > 0);

      for (const stmt of statements) {
        this.db.execute(stmt);
      }

      this.db.execute(
        'INSERT INTO migrations (name) VALUES (?)',
        [migration.name]
      );
    });
  }
}

interface Migration {
  name: string;
  sql: string;
}
```

---

## Tasks

| Task | Estimate |
|------|----------|
| Add better-sqlite3 dependency | 10 min |
| Create SQLiteClient class | 45 min |
| Implement query methods | 30 min |
| Add transaction support | 20 min |
| Create SQLiteMigrator | 45 min |
| Write initial migration | 30 min |
| Add backup/restore | 30 min |
| Write tests | 30 min |

---

## Acceptance Criteria
- [ ] SQLite database creates on first run
- [ ] Migrations run automatically
- [ ] Queries execute correctly
- [ ] Transactions work
- [ ] Database persists across restarts
- [ ] Backup creates valid copy
- [ ] Works cross-platform

---

## Dependencies (npm)

```json
{
  "dependencies": {
    "better-sqlite3": "^9.0.0"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.0"
  }
}
```

---

## CLI Commands

```bash
# Database management commands
bos db status      # Show database info
bos db backup      # Create backup
bos db restore     # Restore from backup
bos db migrate     # Run migrations
bos db reset       # Reset database (with confirmation)
```

---

## Advantages Over PostgreSQL (for CLI)

| Aspect | SQLite | PostgreSQL |
|--------|--------|------------|
| Setup | Zero config | Install + configure |
| Portability | Single file | Requires server |
| Backup | Copy file | pg_dump |
| Deployment | Included | Separate service |
| Performance (local) | Faster | Network overhead |

