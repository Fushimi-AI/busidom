# Feature 11.1: Browser Automation Agent (Future)

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 11.1 |
| **Phase** | 11 - AI Employees & Advanced Automation (Future) |
| **Priority** | Medium |
| **Estimated Effort** | 15-20 hours |
| **Dependencies** | 4.1 (Agent Framework), 4.4 (Agent Orchestration), 4.6 (Dynamic Skills) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Browser automation agent that acts as an AI employee, capable of navigating websites, filling forms, extracting data, and performing complex web tasks autonomously. Delegated to the top orchestrator for intelligent task decomposition and execution.

**Key Philosophy**: Not a general-purpose tool - a specialized AI employee with browser interaction capabilities, supervised by the orchestrator.

---

## User Story

As a **founder**, I want **an AI employee that can handle web-based tasks** so that **I don't waste time on repetitive browser work like research, data entry, or monitoring**.

---

## Requirements

### Functional
1. Browser control (headless Chrome/Playwright)
2. Navigation and interaction (click, type, scroll)
3. Data extraction (scraping, parsing)
4. Form filling and submission
5. Screenshot and visual analysis
6. Multi-step task execution
7. Error handling and recovery
8. Task delegation from orchestrator

### Non-Functional
- Autonomous execution (no manual intervention)
- Error recovery (retry, alternative paths)
- Safety (no destructive actions without confirmation)
- Stealth (avoid bot detection)
- Resource efficient (< 500MB RAM per session)
- Observable (full audit trail of actions)

---

## Technical Specification

### Browser Automation Agent

```typescript
// src/core/agents/browser-automation/browser-agent.ts
import { Page, Browser } from 'playwright';

export interface BrowserTask {
  id: string;
  type: BrowserTaskType;
  description: string;
  url?: string;
  actions: BrowserAction[];
  extractors?: DataExtractor[];
  validation?: TaskValidation;
}

export enum BrowserTaskType {
  NAVIGATE = 'navigate',           // Visit a URL
  EXTRACT = 'extract',             // Scrape data
  INTERACT = 'interact',           // Click/type/fill forms
  MONITOR = 'monitor',             // Watch for changes
  RESEARCH = 'research',           // Multi-step research
  SUBMIT = 'submit'                // Submit forms/data
}

export interface BrowserAction {
  type: 'click' | 'type' | 'scroll' | 'wait' | 'screenshot' | 'select';
  selector?: string;               // CSS/XPath selector
  value?: string;                  // For type/select actions
  description: string;             // What this action does
}

export class BrowserAutomationAgent {
  private browser: Browser;
  private page: Page;

  constructor(
    private orchestrator: AgentOrchestrator,
    private skillGenerator: SkillGenerator
  ) {}

  async executeTask(task: BrowserTask): Promise<BrowserTaskResult> {
    try {
      // Initialize browser session
      await this.initBrowser();

      // Navigate to URL if specified
      if (task.url) {
        await this.page.goto(task.url, { waitUntil: 'networkidle' });
      }

      // Execute actions
      const results: ActionResult[] = [];

      for (const action of task.actions) {
        const result = await this.executeAction(action);
        results.push(result);

        // If action failed, try recovery
        if (!result.success) {
          const recovered = await this.recoverFromError(action, result.error!);
          if (!recovered) {
            throw new Error(`Action failed: ${action.description}`);
          }
        }
      }

      // Extract data if specified
      let extractedData: any = null;

      if (task.extractors) {
        extractedData = await this.extractData(task.extractors);
      }

      // Validate results
      if (task.validation) {
        const valid = await this.validateResults(extractedData, task.validation);
        if (!valid) {
          throw new Error('Task validation failed');
        }
      }

      // Take final screenshot
      const screenshot = await this.page.screenshot();

      return {
        success: true,
        data: extractedData,
        actions: results,
        screenshot
      };

    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        actions: []
      };

    } finally {
      await this.closeBrowser();
    }
  }

  private async executeAction(action: BrowserAction): Promise<ActionResult> {
    console.log(`[BrowserAgent] ${action.description}`);

    try {
      switch (action.type) {
        case 'click':
          await this.page.click(action.selector!);
          break;

        case 'type':
          await this.page.fill(action.selector!, action.value!);
          break;

        case 'scroll':
          await this.page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
          break;

        case 'wait':
          await this.page.waitForTimeout(parseInt(action.value! || '1000'));
          break;

        case 'screenshot':
          await this.page.screenshot({ path: action.value });
          break;

        case 'select':
          await this.page.selectOption(action.selector!, action.value!);
          break;
      }

      return {
        action: action.description,
        success: true
      };

    } catch (error: any) {
      return {
        action: action.description,
        success: false,
        error: error.message
      };
    }
  }

  private async extractData(extractors: DataExtractor[]): Promise<any> {
    const data: Record<string, any> = {};

    for (const extractor of extractors) {
      if (extractor.type === 'selector') {
        // Extract using CSS selector
        data[extractor.name] = await this.page.$(extractor.selector);
      } else if (extractor.type === 'custom') {
        // Use dynamic skill for complex extraction
        const skill = await this.skillGenerator.generateSkill(
          extractor.task!,
          'Extract data from page HTML'
        );

        const html = await this.page.content();
        const result = await this.skillExecutor.execute(skill, { html });

        data[extractor.name] = result.output;
      }
    }

    return data;
  }

  private async recoverFromError(action: BrowserAction, error: string): Promise<boolean> {
    console.log(`[BrowserAgent] Attempting recovery from: ${error}`);

    // Common recovery strategies
    if (error.includes('element not found')) {
      // Wait for element to appear
      try {
        await this.page.waitForSelector(action.selector!, { timeout: 5000 });
        await this.executeAction(action);
        return true;
      } catch {
        return false;
      }
    }

    if (error.includes('timeout')) {
      // Reload page and retry
      try {
        await this.page.reload({ waitUntil: 'networkidle' });
        await this.executeAction(action);
        return true;
      } catch {
        return false;
      }
    }

    // No recovery strategy found
    return false;
  }

  private async initBrowser(): Promise<void> {
    const { chromium } = require('playwright');

    this.browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage'
      ]
    });

    this.page = await this.browser.newPage();

    // Set user agent to avoid bot detection
    await this.page.setUserAgent(
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    );
  }

  private async closeBrowser(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
    }
  }
}
```

---

### Integration with Orchestrator

The orchestrator delegates browser tasks to this agent:

```typescript
// src/core/agents/orchestrator.ts
export class AgentOrchestrator {
  async delegateTask(task: string, context: any): Promise<any> {
    // Determine if task requires browser automation
    const needsBrowser = await this.requiresBrowserAutomation(task);

    if (needsBrowser) {
      // Decompose task into browser actions
      const browserTask = await this.generateBrowserTask(task, context);

      // Delegate to browser agent
      const browserAgent = this.agentRegistry.get('browser-automation');
      return await browserAgent.execute(browserTask);
    }

    // Otherwise delegate to other agents
    return await this.delegateToOtherAgent(task, context);
  }

  private async requiresBrowserAutomation(task: string): Promise<boolean> {
    const browserKeywords = [
      'website', 'webpage', 'scrape', 'extract from',
      'fill form', 'submit', 'click', 'navigate to',
      'search on', 'check if', 'find on page'
    ];

    return browserKeywords.some(keyword => task.toLowerCase().includes(keyword));
  }

  private async generateBrowserTask(task: string, context: any): Promise<BrowserTask> {
    // Use LLM to convert natural language task to structured browser actions
    const prompt = `Convert this task into browser automation steps.

Task: "${task}"

Context: ${JSON.stringify(context)}

Generate a JSON BrowserTask:
{
  "id": "unique-id",
  "type": "navigate|extract|interact|monitor|research|submit",
  "description": "task description",
  "url": "starting URL (if applicable)",
  "actions": [
    {
      "type": "click|type|scroll|wait|screenshot|select",
      "selector": "CSS selector (if applicable)",
      "value": "value (if applicable)",
      "description": "what this action does"
    }
  ],
  "extractors": [
    {
      "name": "data field name",
      "type": "selector|custom",
      "selector": "CSS selector (if type=selector)",
      "task": "extraction task (if type=custom)"
    }
  ]
}

Examples:

Task: "Check competitor pricing on example.com"
{
  "id": "competitor-pricing",
  "type": "extract",
  "url": "https://example.com/pricing",
  "actions": [
    { "type": "wait", "value": "2000", "description": "Wait for page to load" },
    { "type": "screenshot", "value": "pricing.png", "description": "Capture pricing page" }
  ],
  "extractors": [
    { "name": "pricing_tiers", "type": "selector", "selector": ".pricing-tier" }
  ]
}`;

    const response = await this.llm.chat([
      { role: 'system', content: 'You convert tasks to browser automation instructions.' },
      { role: 'user', content: prompt }
    ]);

    return JSON.parse(response.content);
  }
}
```

---

## Use Cases

### 1. Competitive Research
```typescript
// User asks: "What's our competitor's pricing?"
orchestrator.delegateTask("Check competitor pricing on competitor.com/pricing", {
  competitorName: "Competitor Inc"
});

// Browser agent:
// 1. Navigates to competitor.com/pricing
// 2. Extracts pricing tiers and features
// 3. Takes screenshot
// 4. Returns structured data
```

### 2. Form Submission
```typescript
// User asks: "Submit our product to Product Hunt"
orchestrator.delegateTask("Submit product to Product Hunt", {
  productName: "Busidom",
  tagline: "Your AI co-founder",
  description: "...",
  url: "https://business-os.com"
});

// Browser agent:
// 1. Navigates to producthunt.com/submit
// 2. Logs in (credentials from vault)
// 3. Fills form fields
// 4. Uploads images
// 5. Submits
// 6. Returns confirmation
```

### 3. Monitoring
```typescript
// User asks: "Alert me when competitor launches new features"
orchestrator.delegateTask("Monitor competitor.com/changelog for new entries", {
  checkInterval: "daily"
});

// Creates monitoring task (Feature 5.7)
// Browser agent executes daily:
// 1. Navigates to competitor.com/changelog
// 2. Extracts latest entries
// 3. Compares with previous data
// 4. Alerts if new features found
```

---

## Safety & Ethics

### Prohibited Actions
- **No credential harvesting** (only use explicitly provided credentials)
- **No CAPTCHA breaking** (respect bot detection)
- **No DDoS-like behavior** (rate limiting)
- **No data theft** (only extract publicly available data)
- **No impersonation** (clearly identify as bot when required)

### User Confirmation Required
- Form submissions with personal data
- Purchases or financial transactions
- Account creation or modification
- Posting on behalf of user
- Destructive actions (delete, cancel)

---

## Tasks

| Task | Estimate |
|------|----------|
| Create BrowserAutomationAgent class | 3 hours |
| Implement action execution (click, type, etc.) | 2 hours |
| Build data extraction system | 2 hours |
| Add error recovery logic | 2 hours |
| Integrate with orchestrator | 2 hours |
| Implement safety checks | 1.5 hours |
| Add monitoring integration | 1.5 hours |
| Create example use cases | 1 hour |
| Write tests | 2 hours |

---

## Acceptance Criteria
- [ ] Agent executes browser tasks autonomously
- [ ] Actions handle errors and retry
- [ ] Data extraction works (selector + custom)
- [ ] Integration with orchestrator
- [ ] Safety checks prevent prohibited actions
- [ ] User confirmation for sensitive actions
- [ ] Audit trail of all actions
- [ ] Stealth mode avoids bot detection

---

## Success Metrics

**Autonomy:**
- 90%+ tasks complete without manual intervention
- < 5% tasks require user confirmation (false positives)

**Reliability:**
- 95%+ success rate for simple tasks (navigate + extract)
- 80%+ success rate for complex tasks (multi-step)
- 90%+ error recovery rate

**User Value:**
- "Saved me hours of manual work" cited in 60%+ feedback
- 40%+ users create at least one browser automation
- Average 10+ automations per active user

---

## Dependencies

```json
{
  "playwright": "^1.40.0",
  "puppeteer-extra": "^3.3.6",
  "puppeteer-extra-plugin-stealth": "^2.11.2"
}
```

---

## References

- [Playwright Documentation](https://playwright.dev/)
- [AutoGPT Browser Automation](https://github.com/Significant-Gravitas/Auto-GPT)
- [Browser Automation Best Practices](https://www.scrapingbee.com/blog/web-scraping-best-practices/)
- [Avoiding Bot Detection](https://www.zenrows.com/blog/stealth-web-scraping)
