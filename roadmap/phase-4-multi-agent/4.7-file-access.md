# Feature 4.7: Project File Access

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 4.7 |
| **Phase** | 4 - Multi-Agent System |
| **Priority** | Medium |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 4.1 (Agent Framework), 4.6 (Dynamic Skills) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Sandboxed file system access for agents, strictly limited to user-defined project folders. Enables agents to read, analyze, and modify project files (code, docs, configs) while preventing access to system files or parent directories.

**Key Differentiator vs Full System Access**: Security-first design - agents can only touch your project, never your system files, credentials, or personal data.

---

## User Story

As a **user**, I want **agents to access my project files to help with development** so that **they can analyze code, update docs, and manage configs**.

As a **user**, I want **strict sandboxing** so that **agents can never access my system files, SSH keys, or personal data**.

---

## Requirements

### Functional
1. User designates project folder (explicit opt-in)
2. Agents can read files within project
3. Agents can write/modify files within project
4. Agents can create new files/folders within project
5. Path traversal attacks blocked (../, symlinks, etc.)
6. Whitelist/blacklist specific files/patterns
7. File operation logging (audit trail)

### Non-Functional
- 100% prevention of path traversal attacks
- Zero access to files outside project folder
- 0% chance of accessing sensitive files (.env, .ssh/, etc.)
- < 10ms overhead per file operation (security checks)
- Support projects up to 100K files
- Comprehensive audit logging

---

## Technical Specification

### Project Sandbox Configuration

```typescript
// src/core/file-access/project-sandbox.types.ts
export interface ProjectSandbox {
  id: string;
  userId: string;
  businessId: string;
  name: string;                      // "My SaaS Project"
  rootPath: string;                  // Absolute path to project root
  normalizedPath: string;            // Normalized absolute path (for validation)

  // Access controls
  enabled: boolean;
  allowedPatterns: string[];         // Globs: ["**/*.ts", "**/*.md", "package.json"]
  blockedPatterns: string[];         // Globs: [".env*", "**/*.key", ".ssh/**"]

  // Permissions
  allowRead: boolean;
  allowWrite: boolean;
  allowDelete: boolean;
  allowExecute: boolean;             // Execute scripts within project

  // Safety
  requireConfirmation: boolean;      // Ask before destructive operations
  backupBeforeWrite: boolean;        // Auto-backup before modifications

  // Metadata
  createdAt: Date;
  lastAccessedAt: Date;
}

export interface FileOperation {
  id: string;
  sandboxId: string;
  operation: FileOperationType;
  path: string;                      // Relative to project root
  absolutePath: string;              // Full path (for logging)
  success: boolean;
  error?: string;
  timestamp: Date;
  performedBy: string;               // Agent ID
}

export enum FileOperationType {
  READ = 'read',
  WRITE = 'write',
  DELETE = 'delete',
  CREATE = 'create',
  LIST = 'list',
  EXECUTE = 'execute'
}
```

### Sandbox Manager

```typescript
// src/core/file-access/sandbox-manager.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { minimatch } from 'minimatch';

export class SandboxManager {
  constructor(
    private sandboxRepo: ProjectSandboxRepository,
    private operationLogger: FileOperationLogger
  ) {}

  async createSandbox(
    userId: string,
    businessId: string,
    projectPath: string,
    name: string
  ): Promise<ProjectSandbox> {
    // Validate path exists and is a directory
    const stats = await fs.stat(projectPath);
    if (!stats.isDirectory()) {
      throw new Error('Project path must be a directory');
    }

    // Normalize path (resolve symlinks, relative paths)
    const normalizedPath = path.resolve(projectPath);

    // Security: Prevent sandboxing system directories
    const dangerousPaths = [
      '/etc',
      '/usr',
      '/bin',
      '/sbin',
      '/System',
      '/Library',
      '/Windows',
      '/Program Files',
      process.env.HOME + '/.ssh',
      process.env.HOME + '/.aws',
      '/root'
    ];

    for (const dangerous of dangerousPaths) {
      if (normalizedPath.startsWith(dangerous)) {
        throw new Error(`Cannot sandbox system directory: ${dangerous}`);
      }
    }

    // Create sandbox
    const sandbox: ProjectSandbox = {
      id: generateId(),
      userId,
      businessId,
      name,
      rootPath: projectPath,
      normalizedPath,

      enabled: true,
      allowedPatterns: [
        '**/*.ts',
        '**/*.js',
        '**/*.tsx',
        '**/*.jsx',
        '**/*.json',
        '**/*.md',
        '**/*.txt',
        '**/*.yml',
        '**/*.yaml'
      ],
      blockedPatterns: [
        '.env*',
        '**/*.key',
        '**/*.pem',
        '**/*.p12',
        '.ssh/**',
        '.aws/**',
        '**/*secret*',
        '**/*password*',
        '**/node_modules/**',
        '**/.git/**'
      ],

      allowRead: true,
      allowWrite: true,
      allowDelete: false,           // Disabled by default
      allowExecute: false,          // Disabled by default

      requireConfirmation: true,    // Ask before writes
      backupBeforeWrite: true,

      createdAt: new Date(),
      lastAccessedAt: new Date()
    };

    await this.sandboxRepo.create(sandbox);

    console.log(`[SandboxManager] Created sandbox: ${name} at ${normalizedPath}`);

    return sandbox;
  }

  async validatePath(sandboxId: string, requestedPath: string): Promise<{
    valid: boolean;
    absolutePath?: string;
    relativePath?: string;
    error?: string;
  }> {
    const sandbox = await this.sandboxRepo.findById(sandboxId);

    if (!sandbox.enabled) {
      return { valid: false, error: 'Sandbox is disabled' };
    }

    // Resolve requested path
    const absolutePath = path.resolve(sandbox.normalizedPath, requestedPath);

    // CRITICAL: Check path traversal
    if (!absolutePath.startsWith(sandbox.normalizedPath)) {
      return {
        valid: false,
        error: `Path traversal detected: ${requestedPath} resolves outside project`
      };
    }

    // Check for symlinks pointing outside sandbox
    try {
      const realPath = await fs.realpath(absolutePath);
      if (!realPath.startsWith(sandbox.normalizedPath)) {
        return {
          valid: false,
          error: 'Symlink points outside project'
        };
      }
    } catch (error) {
      // File doesn't exist yet (OK for create operations)
    }

    const relativePath = path.relative(sandbox.normalizedPath, absolutePath);

    // Check blocked patterns
    for (const pattern of sandbox.blockedPatterns) {
      if (minimatch(relativePath, pattern)) {
        return {
          valid: false,
          error: `File matches blocked pattern: ${pattern}`
        };
      }
    }

    // Check allowed patterns
    let matchesAllowed = false;
    for (const pattern of sandbox.allowedPatterns) {
      if (minimatch(relativePath, pattern)) {
        matchesAllowed = true;
        break;
      }
    }

    if (!matchesAllowed) {
      return {
        valid: false,
        error: 'File type not in allowed patterns'
      };
    }

    return {
      valid: true,
      absolutePath,
      relativePath
    };
  }
}
```

### File Access Service

```typescript
// src/core/file-access/file-access.service.ts
export class FileAccessService {
  constructor(
    private sandboxManager: SandboxManager,
    private operationLogger: FileOperationLogger,
    private notificationService: NotificationService
  ) {}

  async readFile(
    sandboxId: string,
    filePath: string,
    agentId: string
  ): Promise<string> {
    const sandbox = await this.getSandbox(sandboxId);

    if (!sandbox.allowRead) {
      throw new Error('Read permission denied for this sandbox');
    }

    // Validate path
    const validation = await this.sandboxManager.validatePath(sandboxId, filePath);
    if (!validation.valid) {
      await this.logOperation(sandboxId, FileOperationType.READ, filePath, false, validation.error!, agentId);
      throw new Error(`Access denied: ${validation.error}`);
    }

    try {
      const content = await fs.readFile(validation.absolutePath!, 'utf-8');

      await this.logOperation(sandboxId, FileOperationType.READ, filePath, true, undefined, agentId);

      return content;

    } catch (error: any) {
      await this.logOperation(sandboxId, FileOperationType.READ, filePath, false, error.message, agentId);
      throw error;
    }
  }

  async writeFile(
    sandboxId: string,
    filePath: string,
    content: string,
    agentId: string
  ): Promise<void> {
    const sandbox = await this.getSandbox(sandboxId);

    if (!sandbox.allowWrite) {
      throw new Error('Write permission denied for this sandbox');
    }

    // Validate path
    const validation = await this.sandboxManager.validatePath(sandboxId, filePath);
    if (!validation.valid) {
      await this.logOperation(sandboxId, FileOperationType.WRITE, filePath, false, validation.error!, agentId);
      throw new Error(`Access denied: ${validation.error}`);
    }

    // Confirmation required?
    if (sandbox.requireConfirmation) {
      const confirmed = await this.requestConfirmation(
        sandbox.userId,
        `Agent wants to write to: ${validation.relativePath}`,
        content
      );

      if (!confirmed) {
        await this.logOperation(sandboxId, FileOperationType.WRITE, filePath, false, 'User rejected', agentId);
        throw new Error('Write operation rejected by user');
      }
    }

    try {
      // Backup existing file
      if (sandbox.backupBeforeWrite) {
        await this.backupFile(validation.absolutePath!);
      }

      // Write file
      await fs.writeFile(validation.absolutePath!, content, 'utf-8');

      await this.logOperation(sandboxId, FileOperationType.WRITE, filePath, true, undefined, agentId);

      console.log(`[FileAccess] Wrote ${validation.relativePath}`);

    } catch (error: any) {
      await this.logOperation(sandboxId, FileOperationType.WRITE, filePath, false, error.message, agentId);
      throw error;
    }
  }

  async listFiles(
    sandboxId: string,
    dirPath: string = '.',
    agentId: string
  ): Promise<string[]> {
    const sandbox = await this.getSandbox(sandboxId);

    // Validate path
    const validation = await this.sandboxManager.validatePath(sandboxId, dirPath);
    if (!validation.valid) {
      throw new Error(`Access denied: ${validation.error}`);
    }

    try {
      const entries = await fs.readdir(validation.absolutePath!, { withFileTypes: true });

      const files = entries
        .filter(entry => entry.isFile())
        .map(entry => path.join(dirPath, entry.name));

      await this.logOperation(sandboxId, FileOperationType.LIST, dirPath, true, undefined, agentId);

      return files;

    } catch (error: any) {
      await this.logOperation(sandboxId, FileOperationType.LIST, dirPath, false, error.message, agentId);
      throw error;
    }
  }

  async deleteFile(
    sandboxId: string,
    filePath: string,
    agentId: string
  ): Promise<void> {
    const sandbox = await this.getSandbox(sandboxId);

    if (!sandbox.allowDelete) {
      throw new Error('Delete permission denied for this sandbox');
    }

    // Validate path
    const validation = await this.sandboxManager.validatePath(sandboxId, filePath);
    if (!validation.valid) {
      throw new Error(`Access denied: ${validation.error}`);
    }

    // ALWAYS require confirmation for deletes
    const confirmed = await this.requestConfirmation(
      sandbox.userId,
      `Agent wants to DELETE: ${validation.relativePath}`,
      'This action cannot be undone.'
    );

    if (!confirmed) {
      await this.logOperation(sandboxId, FileOperationType.DELETE, filePath, false, 'User rejected', agentId);
      throw new Error('Delete operation rejected by user');
    }

    try {
      // Backup before delete
      await this.backupFile(validation.absolutePath!);

      await fs.unlink(validation.absolutePath!);

      await this.logOperation(sandboxId, FileOperationType.DELETE, filePath, true, undefined, agentId);

      console.log(`[FileAccess] Deleted ${validation.relativePath}`);

    } catch (error: any) {
      await this.logOperation(sandboxId, FileOperationType.DELETE, filePath, false, error.message, agentId);
      throw error;
    }
  }

  private async getSandbox(sandboxId: string): Promise<ProjectSandbox> {
    const sandbox = await this.sandboxRepo.findById(sandboxId);

    if (!sandbox) {
      throw new Error(`Sandbox not found: ${sandboxId}`);
    }

    if (!sandbox.enabled) {
      throw new Error('Sandbox is disabled');
    }

    return sandbox;
  }

  private async backupFile(filePath: string): Promise<void> {
    try {
      const exists = await fs.access(filePath).then(() => true).catch(() => false);

      if (exists) {
        const backupPath = `${filePath}.backup.${Date.now()}`;
        await fs.copyFile(filePath, backupPath);
        console.log(`[FileAccess] Backed up to ${backupPath}`);
      }
    } catch (error) {
      console.warn(`[FileAccess] Backup failed:`, error);
      // Don't throw - backup is best-effort
    }
  }

  private async requestConfirmation(
    userId: string,
    message: string,
    details: string
  ): Promise<boolean> {
    // Send notification and wait for user response
    // In CLI: prompt user immediately
    // In Web: show modal, wait for response
    // Simplified for now
    return true;
  }

  private async logOperation(
    sandboxId: string,
    operation: FileOperationType,
    path: string,
    success: boolean,
    error: string | undefined,
    agentId: string
  ): Promise<void> {
    const log: FileOperation = {
      id: generateId(),
      sandboxId,
      operation,
      path,
      absolutePath: path,
      success,
      error,
      timestamp: new Date(),
      performedBy: agentId
    };

    await this.operationLogger.log(log);
  }
}
```

### Agent Integration

```typescript
// src/core/agents/tools/file-access.tool.ts
export class FileAccessTool implements AgentTool {
  name = 'file_access';
  description = 'Read and write files within the project sandbox';

  constructor(
    private fileAccessService: FileAccessService,
    private sandboxId: string
  ) {}

  get schema() {
    return {
      type: 'object',
      properties: {
        action: {
          type: 'string',
          enum: ['read', 'write', 'list', 'delete'],
          description: 'File operation to perform'
        },
        path: {
          type: 'string',
          description: 'Path to file (relative to project root)'
        },
        content: {
          type: 'string',
          description: 'Content to write (for write action)'
        }
      },
      required: ['action', 'path']
    };
  }

  async execute(params: {
    action: 'read' | 'write' | 'list' | 'delete';
    path: string;
    content?: string;
  }, agentId: string): Promise<any> {
    switch (params.action) {
      case 'read':
        return this.fileAccessService.readFile(this.sandboxId, params.path, agentId);

      case 'write':
        if (!params.content) {
          throw new Error('Content required for write action');
        }
        await this.fileAccessService.writeFile(this.sandboxId, params.path, params.content, agentId);
        return { success: true };

      case 'list':
        return this.fileAccessService.listFiles(this.sandboxId, params.path, agentId);

      case 'delete':
        await this.fileAccessService.deleteFile(this.sandboxId, params.path, agentId);
        return { success: true };

      default:
        throw new Error(`Unknown action: ${params.action}`);
    }
  }
}
```

---

## CLI Integration

```typescript
// src/cli/commands/sandbox.command.ts
export async function setupSandbox() {
  const sandboxManager = container.resolve<SandboxManager>('SandboxManager');
  const currentUser = await getCurrentUser();

  console.log(chalk.bold('\nüìÅ Setup Project Sandbox\n'));
  console.log(chalk.gray('Grant agents access to your project files.\n'));

  const projectPath = await askQuestion('Project folder path: ');
  const name = await askQuestion('Project name: ');

  console.log(chalk.yellow('\n‚ö†Ô∏è  Security Notice:'));
  console.log(chalk.gray('Agents will be able to read and modify files in this folder.'));
  console.log(chalk.gray('System files, credentials, and parent directories are blocked.\n'));

  const confirm = await askConfirm('Continue?');
  if (!confirm) {
    console.log(chalk.gray('Cancelled.\n'));
    return;
  }

  try {
    const sandbox = await sandboxManager.createSandbox(
      currentUser.id,
      currentUser.currentBusinessId,
      projectPath,
      name
    );

    console.log(chalk.green('\n‚úÖ Sandbox created successfully\n'));
    console.log(chalk.blue(`Project: ${name}`));
    console.log(chalk.gray(`Path: ${sandbox.rootPath}`));
    console.log(chalk.gray(`\nAllowed file types: ${sandbox.allowedPatterns.join(', ')}`));
    console.log(chalk.gray(`Blocked patterns: ${sandbox.blockedPatterns.join(', ')}\n`));

  } catch (error: any) {
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
  }
}

export async function listSandboxes() {
  const sandboxRepo = container.resolve<ProjectSandboxRepository>('ProjectSandboxRepository');
  const currentUser = await getCurrentUser();

  const sandboxes = await sandboxRepo.findByUserId(currentUser.id);

  console.log(chalk.bold('\nüìÅ Your Project Sandboxes\n'));

  for (const sandbox of sandboxes) {
    const statusColor = sandbox.enabled ? chalk.green : chalk.red;

    console.log(chalk.blue(`‚Ä¢ ${sandbox.name}`));
    console.log(chalk.gray(`  Path: ${sandbox.rootPath}`));
    console.log(statusColor(`  Status: ${sandbox.enabled ? 'Enabled' : 'Disabled'}`));

    const permissions = [];
    if (sandbox.allowRead) permissions.push('read');
    if (sandbox.allowWrite) permissions.push('write');
    if (sandbox.allowDelete) permissions.push('delete');

    console.log(chalk.gray(`  Permissions: ${permissions.join(', ')}`));
    console.log();
  }

  if (sandboxes.length === 0) {
    console.log(chalk.gray('No sandboxes configured.\n'));
    console.log(chalk.gray('Run `busidom sandbox setup` to create one.\n'));
  }
}

export async function viewAuditLog() {
  const operationLogger = container.resolve<FileOperationLogger>('FileOperationLogger');

  const sandboxId = await askQuestion('Sandbox ID: ');
  const operations = await operationLogger.getRecentOperations(sandboxId, 50);

  console.log(chalk.bold('\nüìã File Operation Audit Log\n'));

  for (const op of operations) {
    const icon = op.success ? chalk.green('‚úì') : chalk.red('‚úó');
    const time = formatRelativeTime(op.timestamp);

    console.log(`${icon} ${chalk.blue(op.operation.toUpperCase())} ${op.path}`);
    console.log(chalk.gray(`  ${time} by ${op.performedBy}`));

    if (!op.success && op.error) {
      console.log(chalk.red(`  Error: ${op.error}`));
    }

    console.log();
  }
}
```

---

## Security Considerations

### 1. Path Traversal Prevention
- All paths normalized and validated
- Symlinks resolved and checked
- `../ ` sequences blocked
- Absolute path comparison (no string matching)

### 2. Sensitive File Protection
- `.env*`, `*.key`, `*.pem` blocked by default
- `.ssh/`, `.aws/` directories blocked
- User can customize blocked patterns

### 3. System Directory Protection
- Cannot sandbox `/etc`, `/usr`, `/System`, etc.
- Home directory requires explicit confirmation
- Root directories always blocked

### 4. Audit Trail
- Every file operation logged
- Includes: path, operation, timestamp, agent, success/failure
- Immutable logs (cannot be deleted by agents)

### 5. User Confirmation
- Destructive operations (write, delete) require confirmation
- User can disable for trusted agents
- Always confirm deletes (even if disabled)

---

## Tasks

| Task | Estimate |
|------|----------|
| Create ProjectSandbox model & repository | 30 min |
| Implement SandboxManager (validation logic) | 90 min |
| Build FileAccessService (CRUD operations) | 75 min |
| Create FileAccessTool for agents | 30 min |
| Implement audit logging | 30 min |
| Create CLI commands | 45 min |
| Write security tests (path traversal, etc.) | 60 min |

---

## Acceptance Criteria
- [ ] 100% prevention of path traversal attacks
- [ ] Zero access outside sandbox (tested with 1000+ attack vectors)
- [ ] Sensitive files (.env, .ssh, etc.) always blocked
- [ ] All operations logged to audit trail
- [ ] User confirmation for destructive operations
- [ ] Integration with agent tools

---

## Success Metrics

**Security:**
- 0 successful path traversal attacks (penetration tested)
- 0 accesses to files outside sandbox
- 100% sensitive file blocking

**Usability:**
- 80%+ users enable sandbox for at least one project
- < 5% false positive blocks (legitimate files blocked)
- 90%+ users trust sandbox security (survey)

**Performance:**
- < 10ms path validation overhead
- Support 100K+ files in project
- < 1% performance impact on agent operations

---

## References

- [OWASP: Path Traversal Attacks](https://owasp.org/www-community/attacks/Path_Traversal)
- [Node.js Security Best Practices: File Access](https://nodejs.org/en/docs/guides/security/)
- [Sandboxing File System Access](https://www.electronjs.org/docs/latest/tutorial/security#14-disable-or-limit-navigation)
