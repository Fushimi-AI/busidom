# Feature 2.5: Data Export/Import

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 2.5 |
| **Phase** | 2 - Persistence |
| **Priority** | Medium |
| **Estimated Effort** | 3-4 hours |
| **Dependencies** | 2.3 (Conversation Storage), 2.4 (Business Entity) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Enable users to export all their data (businesses, conversations, context) and import it back. Supports data portability and backup.

## User Story

As a **user**, I want to **export all my data** so that **I own my data and can back it up**.

---

## Requirements

### Functional Requirements
1. Export all user data to JSON
2. Export specific business data
3. Export conversations as Markdown
4. Import data from export file
5. /export and /import commands

### Non-Functional Requirements
- Export completes in < 30 seconds
- Support exports up to 100MB
- Validate imports before applying
- No data loss on import

---

## Technical Specification

### Export Format

```typescript
// src/types/export.ts
export interface ExportData {
  version: string;          // Export format version
  exportedAt: string;       // ISO date
  user: {
    id: string;
    email: string;
  };
  businesses: ExportBusiness[];
}

export interface ExportBusiness {
  id: string;
  name: string;
  industry: string | null;
  stage: string;
  context: BusinessContext;
  conversations: ExportConversation[];
  createdAt: string;
  updatedAt: string;
}

export interface ExportConversation {
  id: string;
  title: string;
  messages: ExportMessage[];
  createdAt: string;
  updatedAt: string;
}

export interface ExportMessage {
  role: string;
  content: string;
  timestamp: string;
}
```

### Export Service

```typescript
// src/core/export/export.service.ts
import * as fs from 'fs/promises';
import { BusinessRepository } from '../../infrastructure/repositories/business.repository';
import { ConversationRepository } from '../../infrastructure/repositories/conversation.repository';
import { MessageRepository } from '../../infrastructure/repositories/message.repository';
import { ExportData, ExportBusiness } from '../../types';

export class ExportService {
  constructor(
    private businessRepo: BusinessRepository,
    private conversationRepo: ConversationRepository,
    private messageRepo: MessageRepository
  ) {}

  async exportAll(userId: string): Promise<ExportData> {
    const businesses = await this.businessRepo.findByUserId(userId);

    const exportBusinesses: ExportBusiness[] = [];

    for (const business of businesses) {
      const conversations = await this.conversationRepo.findByBusinessId(business.id);

      const exportConversations = [];

      for (const conv of conversations) {
        const messages = await this.messageRepo.findByConversationId(conv.id);

        exportConversations.push({
          id: conv.id,
          title: conv.title,
          messages: messages.map(m => ({
            role: m.role,
            content: m.content,
            timestamp: m.timestamp.toISOString(),
          })),
          createdAt: conv.createdAt.toISOString(),
          updatedAt: conv.updatedAt.toISOString(),
        });
      }

      exportBusinesses.push({
        id: business.id,
        name: business.name,
        industry: business.industry,
        stage: business.stage,
        context: business.context,
        conversations: exportConversations,
        createdAt: business.createdAt.toISOString(),
        updatedAt: business.updatedAt.toISOString(),
      });
    }

    return {
      version: '1.0',
      exportedAt: new Date().toISOString(),
      user: {
        id: userId,
        email: '', // Filled by caller
      },
      businesses: exportBusinesses,
    };
  }

  async exportToFile(userId: string, filePath: string): Promise<void> {
    const data = await this.exportAll(userId);
    const json = JSON.stringify(data, null, 2);
    await fs.writeFile(filePath, json, 'utf-8');
  }

  async exportToMarkdown(userId: string, outputDir: string): Promise<void> {
    const data = await this.exportAll(userId);

    await fs.mkdir(outputDir, { recursive: true });

    for (const business of data.businesses) {
      const businessDir = `${outputDir}/${this.sanitize(business.name)}`;
      await fs.mkdir(businessDir, { recursive: true });

      // Business summary
      const summaryMd = this.generateBusinessSummary(business);
      await fs.writeFile(`${businessDir}/README.md`, summaryMd);

      // Conversations
      for (const conv of business.conversations) {
        const convMd = this.generateConversationMarkdown(conv);
        const filename = `${this.sanitize(conv.title || conv.id)}.md`;
        await fs.writeFile(`${businessDir}/${filename}`, convMd);
      }
    }
  }

  private generateBusinessSummary(business: ExportBusiness): string {
    return `# ${business.name}

**Stage:** ${business.stage}
**Industry:** ${business.industry || 'Not set'}

## Context

**Target Customer:** ${business.context.targetCustomer || 'Not defined'}

**Problem:** ${business.context.problemStatement || 'Not defined'}

### Challenges
${business.context.challenges.map(c => `- ${c}`).join('\n') || 'None identified'}

### Goals
${business.context.goals.map(g => `- ${g}`).join('\n') || 'None set'}

## Conversations

${business.conversations.map(c => `- [${c.title || 'Untitled'}](./${this.sanitize(c.title || c.id)}.md) (${c.messages.length} messages)`).join('\n')}

---
*Exported: ${new Date().toISOString()}*
`;
  }

  private generateConversationMarkdown(conv: ExportConversation): string {
    let md = `# ${conv.title || 'Conversation'}\n\n`;
    md += `*Started: ${conv.createdAt}*\n\n---\n\n`;

    for (const msg of conv.messages) {
      const role = msg.role === 'user' ? '**You:**' : '**Mentor:**';
      md += `${role}\n\n${msg.content}\n\n---\n\n`;
    }

    return md;
  }

  private sanitize(name: string): string {
    return name.replace(/[^a-zA-Z0-9-_]/g, '_').slice(0, 50);
  }
}
```

### Import Service

```typescript
// src/core/export/import.service.ts
import * as fs from 'fs/promises';
import { ExportData } from '../../types';
import { BusinessRepository } from '../../infrastructure/repositories/business.repository';
import { ConversationRepository } from '../../infrastructure/repositories/conversation.repository';
import { MessageRepository } from '../../infrastructure/repositories/message.repository';
import { ValidationError } from '../errors';

export class ImportService {
  constructor(
    private businessRepo: BusinessRepository,
    private conversationRepo: ConversationRepository,
    private messageRepo: MessageRepository,
    private db: DatabaseClient
  ) {}

  async importFromFile(filePath: string, userId: string): Promise<ImportResult> {
    const content = await fs.readFile(filePath, 'utf-8');
    const data: ExportData = JSON.parse(content);

    // Validate
    this.validate(data);

    return this.importData(data, userId);
  }

  private validate(data: ExportData): void {
    if (!data.version) {
      throw new ValidationError('Invalid export file: missing version');
    }

    if (!data.businesses || !Array.isArray(data.businesses)) {
      throw new ValidationError('Invalid export file: missing businesses');
    }

    // Add more validation as needed
  }

  async importData(data: ExportData, userId: string): Promise<ImportResult> {
    const result: ImportResult = {
      businessesImported: 0,
      conversationsImported: 0,
      messagesImported: 0,
      errors: [],
    };

    await this.db.transaction(async (client) => {
      for (const business of data.businesses) {
        try {
          // Create business with new ID (avoid conflicts)
          const newBusiness = await this.businessRepo.create({
            userId,
            name: `${business.name} (imported)`,
            industry: business.industry,
            stage: business.stage as BusinessStage,
          });

          // Update context
          await this.businessRepo.updateContext(newBusiness.id, business.context);
          result.businessesImported++;

          // Import conversations
          for (const conv of business.conversations) {
            const newConv = await this.conversationRepo.create({
              businessId: newBusiness.id,
              title: conv.title,
            });
            result.conversationsImported++;

            // Import messages
            for (const msg of conv.messages) {
              await this.messageRepo.create({
                conversationId: newConv.id,
                role: msg.role as 'user' | 'assistant',
                content: msg.content,
              });
              result.messagesImported++;
            }
          }
        } catch (error) {
          result.errors.push(`Failed to import ${business.name}: ${error.message}`);
        }
      }
    });

    return result;
  }
}

interface ImportResult {
  businessesImported: number;
  conversationsImported: number;
  messagesImported: number;
  errors: string[];
}
```

### CLI Commands

```typescript
// src/cli/commands/export.commands.ts
import chalk from 'chalk';
import * as path from 'path';

export function registerExportCommands(
  repl: REPL,
  exportService: ExportService,
  importService: ImportService
): void {
  repl.registerCommand('/export', async (args: string) => {
    const format = args.trim() || 'json';
    const timestamp = new Date().toISOString().split('T')[0];
    const basePath = path.join(process.env.HOME || '.', 'bos-export');

    try {
      if (format === 'json') {
        const filePath = `${basePath}-${timestamp}.json`;
        await exportService.exportToFile(getCurrentUserId(), filePath);
        console.log(chalk.green(`✓ Exported to ${filePath}`));
      } else if (format === 'markdown' || format === 'md') {
        const dirPath = `${basePath}-${timestamp}`;
        await exportService.exportToMarkdown(getCurrentUserId(), dirPath);
        console.log(chalk.green(`✓ Exported to ${dirPath}/`));
      } else {
        console.log(chalk.yellow('Usage: /export [json|markdown]'));
      }
    } catch (error) {
      console.log(chalk.red(`Export failed: ${error.message}`));
    }
  });

  repl.registerCommand('/import', async (args: string) => {
    const filePath = args.trim();

    if (!filePath) {
      console.log(chalk.yellow('Usage: /import <path-to-export.json>'));
      return;
    }

    try {
      const result = await importService.importFromFile(filePath, getCurrentUserId());

      console.log(chalk.green(`✓ Import complete:`));
      console.log(`  Businesses: ${result.businessesImported}`);
      console.log(`  Conversations: ${result.conversationsImported}`);
      console.log(`  Messages: ${result.messagesImported}`);

      if (result.errors.length > 0) {
        console.log(chalk.yellow('\nWarnings:'));
        result.errors.forEach(e => console.log(`  - ${e}`));
      }
    } catch (error) {
      console.log(chalk.red(`Import failed: ${error.message}`));
    }
  });
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 2.5.1 | Define export types | 15 min |
| 2.5.2 | Implement ExportService | 45 min |
| 2.5.3 | Add Markdown export | 30 min |
| 2.5.4 | Implement ImportService | 45 min |
| 2.5.5 | Add import validation | 20 min |
| 2.5.6 | Implement /export command | 20 min |
| 2.5.7 | Implement /import command | 20 min |
| 2.5.8 | Write unit tests | 30 min |

---

## Acceptance Criteria

- [ ] Export all data to JSON works
- [ ] Export to Markdown works
- [ ] Import from JSON works
- [ ] Import validates data
- [ ] Import doesn't overwrite existing
- [ ] Large exports complete < 30s
- [ ] /export and /import commands work

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Round-trip tested (export → import)
- [ ] Large dataset tested
- [ ] Error handling verified

