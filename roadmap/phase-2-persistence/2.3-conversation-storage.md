# Feature 2.3: Conversation Storage

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 2.3 |
| **Phase** | 2 - Persistence |
| **Priority** | Critical |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 2.1 (PostgreSQL), 2.2 (User Auth) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Migrate conversation storage from JSON files to PostgreSQL, enabling multi-device access, better search, and reliable persistence.

## User Story

As a **user**, I want my **conversations stored in a database** so that **I can access them from any device**.

---

## Requirements

### Functional Requirements
1. Store conversations in PostgreSQL
2. Store messages with metadata
3. Query conversations by user/business
4. Search messages by content
5. Paginated conversation history
6. Backward compatible with JSON storage

### Non-Functional Requirements
- Message insert < 50ms
- Conversation load < 200ms
- Support 10K+ messages per conversation
- Efficient pagination

---

## Technical Specification

### Conversation Repository

```typescript
// src/infrastructure/repositories/conversation.repository.ts
import { BaseRepository } from '../database/base.repository';
import { Conversation, Message } from '../../types';

interface ConversationRow {
  id: string;
  business_id: string;
  title: string;
  message_count: number;
  created_at: Date;
  updated_at: Date;
}

export class ConversationRepository extends BaseRepository<ConversationRow> {
  constructor(db: DatabaseClient) {
    super(db, 'conversations');
  }

  async findByBusinessId(
    businessId: string,
    limit: number = 20,
    offset: number = 0
  ): Promise<Conversation[]> {
    const rows = await this.db.query<ConversationRow>(
      `SELECT * FROM conversations
       WHERE business_id = $1
       ORDER BY updated_at DESC
       LIMIT $2 OFFSET $3`,
      [businessId, limit, offset]
    );

    return rows.map(this.toConversation);
  }

  async create(data: {
    businessId: string;
    title?: string;
  }): Promise<Conversation> {
    const row = await this.insert({
      business_id: data.businessId,
      title: data.title || '',
      message_count: 0,
    });

    return this.toConversation(row);
  }

  async updateMessageCount(id: string, count: number): Promise<void> {
    await this.db.execute(
      `UPDATE conversations SET message_count = $2, updated_at = NOW() WHERE id = $1`,
      [id, count]
    );
  }

  async updateTitle(id: string, title: string): Promise<void> {
    await this.db.execute(
      `UPDATE conversations SET title = $2 WHERE id = $1`,
      [id, title]
    );
  }

  private toConversation(row: ConversationRow): Conversation {
    return {
      id: row.id,
      businessId: row.business_id,
      title: row.title,
      messageCount: row.message_count,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
```

### Message Repository

```typescript
// src/infrastructure/repositories/message.repository.ts
import { BaseRepository } from '../database/base.repository';
import { Message } from '../../types';

interface MessageRow {
  id: string;
  conversation_id: string;
  role: string;
  content: string;
  metadata: Record<string, unknown>;
  created_at: Date;
}

export class MessageRepository extends BaseRepository<MessageRow> {
  constructor(db: DatabaseClient) {
    super(db, 'messages');
  }

  async findByConversationId(
    conversationId: string,
    limit?: number,
    offset: number = 0
  ): Promise<Message[]> {
    let sql = `
      SELECT * FROM messages
      WHERE conversation_id = $1
      ORDER BY created_at ASC
    `;
    const params: unknown[] = [conversationId];

    if (limit) {
      sql += ` LIMIT $2 OFFSET $3`;
      params.push(limit, offset);
    }

    const rows = await this.db.query<MessageRow>(sql, params);
    return rows.map(this.toMessage);
  }

  async create(data: {
    conversationId: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    metadata?: Record<string, unknown>;
  }): Promise<Message> {
    const row = await this.insert({
      conversation_id: data.conversationId,
      role: data.role,
      content: data.content,
      metadata: data.metadata || {},
    });

    return this.toMessage(row);
  }

  async search(
    conversationId: string,
    query: string,
    limit: number = 20
  ): Promise<Message[]> {
    const rows = await this.db.query<MessageRow>(
      `SELECT * FROM messages
       WHERE conversation_id = $1
       AND content ILIKE $2
       ORDER BY created_at DESC
       LIMIT $3`,
      [conversationId, `%${query}%`, limit]
    );

    return rows.map(this.toMessage);
  }

  async getLatest(conversationId: string, count: number): Promise<Message[]> {
    const rows = await this.db.query<MessageRow>(
      `SELECT * FROM (
         SELECT * FROM messages
         WHERE conversation_id = $1
         ORDER BY created_at DESC
         LIMIT $2
       ) sub ORDER BY created_at ASC`,
      [conversationId, count]
    );

    return rows.map(this.toMessage);
  }

  async deleteByConversationId(conversationId: string): Promise<number> {
    return this.db.execute(
      `DELETE FROM messages WHERE conversation_id = $1`,
      [conversationId]
    );
  }

  private toMessage(row: MessageRow): Message {
    return {
      id: row.id,
      role: row.role as 'user' | 'assistant' | 'system',
      content: row.content,
      timestamp: row.created_at,
      metadata: row.metadata,
    };
  }
}
```

### Database Memory Service

```typescript
// src/core/memory/db-memory.service.ts
import { ConversationRepository } from '../../infrastructure/repositories/conversation.repository';
import { MessageRepository } from '../../infrastructure/repositories/message.repository';
import { IMemoryService } from '../interfaces/memory.interface';
import { Message, Conversation } from '../../types';

export class DatabaseMemoryService implements IMemoryService {
  private currentConversation: Conversation | null = null;
  private messageCache: Message[] = [];

  constructor(
    private conversationRepo: ConversationRepository,
    private messageRepo: MessageRepository
  ) {}

  async init(businessId: string): Promise<void> {
    // Load most recent conversation or create new
    const conversations = await this.conversationRepo.findByBusinessId(businessId, 1);

    if (conversations.length > 0) {
      this.currentConversation = conversations[0];
      this.messageCache = await this.messageRepo.findByConversationId(
        this.currentConversation.id
      );
    }
  }

  async addMessage(message: Message): Promise<void> {
    if (!this.currentConversation) {
      throw new Error('No active conversation');
    }

    const saved = await this.messageRepo.create({
      conversationId: this.currentConversation.id,
      role: message.role,
      content: message.content,
      metadata: message.metadata,
    });

    this.messageCache.push(saved);

    // Update conversation
    await this.conversationRepo.updateMessageCount(
      this.currentConversation.id,
      this.messageCache.length
    );

    // Set title from first user message
    if (!this.currentConversation.title && message.role === 'user') {
      const title = message.content.slice(0, 50) + (message.content.length > 50 ? '...' : '');
      await this.conversationRepo.updateTitle(this.currentConversation.id, title);
      this.currentConversation.title = title;
    }
  }

  async startNewConversation(businessId: string): Promise<void> {
    this.currentConversation = await this.conversationRepo.create({
      businessId,
    });
    this.messageCache = [];
  }

  async loadConversation(id: string): Promise<boolean> {
    const conversation = await this.conversationRepo.findById(id);

    if (!conversation) {
      return false;
    }

    this.currentConversation = this.conversationRepo['toConversation'](conversation);
    this.messageCache = await this.messageRepo.findByConversationId(id);
    return true;
  }

  async listConversations(businessId: string): Promise<Conversation[]> {
    return this.conversationRepo.findByBusinessId(businessId);
  }

  async searchMessages(query: string): Promise<Message[]> {
    if (!this.currentConversation) {
      return [];
    }

    return this.messageRepo.search(this.currentConversation.id, query);
  }

  getMessages(): Message[] {
    return [...this.messageCache];
  }

  getRecentMessages(count: number): Message[] {
    return this.messageCache.slice(-count);
  }

  clear(): void {
    this.messageCache = [];
  }

  getCurrentConversation(): Conversation | null {
    return this.currentConversation;
  }
}
```

### Storage Factory

```typescript
// src/infrastructure/storage/factory.ts
import { Config } from '../../config';
import { IMemoryService } from '../../core/interfaces/memory.interface';
import { JSONMemoryService } from './json-memory.service';
import { DatabaseMemoryService } from '../../core/memory/db-memory.service';

export function createMemoryService(config: Config): IMemoryService {
  if (config.storage.type === 'postgres') {
    const db = new DatabaseClient(config.database);
    const convRepo = new ConversationRepository(db);
    const msgRepo = new MessageRepository(db);
    return new DatabaseMemoryService(convRepo, msgRepo);
  }

  return new JSONMemoryService(config.storage.path);
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 2.3.1 | Create ConversationRepository | 45 min |
| 2.3.2 | Create MessageRepository | 45 min |
| 2.3.3 | Implement DatabaseMemoryService | 60 min |
| 2.3.4 | Add message search | 30 min |
| 2.3.5 | Implement pagination | 20 min |
| 2.3.6 | Create storage factory | 20 min |
| 2.3.7 | Update CLI commands | 30 min |
| 2.3.8 | Add migration for JSON → DB | 30 min |
| 2.3.9 | Write integration tests | 45 min |

---

## Acceptance Criteria

- [ ] Conversations stored in PostgreSQL
- [ ] Messages stored with metadata
- [ ] Conversation list by business
- [ ] Message search works
- [ ] Pagination works
- [ ] Insert < 50ms
- [ ] Load < 200ms
- [ ] Backward compatible (JSON fallback)

---

## File Structure

```
src/
├── core/
│   ├── interfaces/
│   │   └── memory.interface.ts
│   └── memory/
│       └── db-memory.service.ts
└── infrastructure/
    ├── repositories/
    │   ├── conversation.repository.ts
    │   └── message.repository.ts
    └── storage/
        ├── factory.ts
        └── json-memory.service.ts
```

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Performance benchmarks met
- [ ] Migration tested
- [ ] Integration tests passing

