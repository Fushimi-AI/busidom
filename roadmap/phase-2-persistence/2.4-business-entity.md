# Feature 2.4: Business Entity Model

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 2.4 |
| **Phase** | 2 - Persistence |
| **Priority** | High |
| **Estimated Effort** | 4-5 hours |
| **Dependencies** | 2.1 (PostgreSQL), 2.2 (User Auth) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement the Business entity for multi-business support, allowing users to track multiple ventures with separate contexts, conversations, and stages.

## User Story

As a **serial entrepreneur**, I want to **manage multiple businesses** so that **each venture has its own context and history**.

---

## Requirements

### Functional Requirements
1. Create/update/delete businesses
2. Switch between businesses
3. Store business context (stage, challenges, etc.)
4. Link conversations to businesses
5. /business command to manage
6. Default business on first run

### Non-Functional Requirements
- Support up to 10 businesses per user (starter)
- Business switch < 100ms
- Context persists across sessions

---

## Technical Specification

### Business Entity

```typescript
// src/types/business.ts
export interface Business {
  id: string;
  userId: string;
  name: string;
  industry: string | null;
  stage: BusinessStage;
  context: BusinessContext;
  createdAt: Date;
  updatedAt: Date;
}

export interface BusinessContext {
  targetCustomer: string | null;
  problemStatement: string | null;
  challenges: string[];
  goals: string[];
  milestones: Milestone[];
  keyDecisions: Decision[];
  notes: string | null;
}

export enum BusinessStage {
  IDEA = 'idea',
  MVP = 'mvp',
  GROWTH = 'growth',
  SCALE = 'scale',
}

export interface CreateBusinessInput {
  name: string;
  industry?: string;
  stage?: BusinessStage;
}
```

### Business Repository

```typescript
// src/infrastructure/repositories/business.repository.ts
import { BaseRepository } from '../database/base.repository';
import { Business, BusinessContext, BusinessStage } from '../../types';

interface BusinessRow {
  id: string;
  user_id: string;
  name: string;
  industry: string | null;
  stage: string;
  context: BusinessContext;
  created_at: Date;
  updated_at: Date;
}

export class BusinessRepository extends BaseRepository<BusinessRow> {
  constructor(db: DatabaseClient) {
    super(db, 'businesses');
  }

  async findByUserId(userId: string): Promise<Business[]> {
    const rows = await this.db.query<BusinessRow>(
      `SELECT * FROM businesses
       WHERE user_id = $1
       ORDER BY updated_at DESC`,
      [userId]
    );

    return rows.map(this.toBusiness);
  }

  async create(data: {
    userId: string;
    name: string;
    industry?: string;
    stage?: BusinessStage;
  }): Promise<Business> {
    const row = await this.insert({
      user_id: data.userId,
      name: data.name,
      industry: data.industry || null,
      stage: data.stage || BusinessStage.IDEA,
      context: {
        targetCustomer: null,
        problemStatement: null,
        challenges: [],
        goals: [],
        milestones: [],
        keyDecisions: [],
        notes: null,
      },
    });

    return this.toBusiness(row);
  }

  async updateContext(id: string, context: Partial<BusinessContext>): Promise<void> {
    // Merge with existing context using JSONB operators
    await this.db.execute(
      `UPDATE businesses
       SET context = context || $2::jsonb,
           updated_at = NOW()
       WHERE id = $1`,
      [id, JSON.stringify(context)]
    );
  }

  async updateStage(id: string, stage: BusinessStage): Promise<void> {
    await this.db.execute(
      `UPDATE businesses SET stage = $2, updated_at = NOW() WHERE id = $1`,
      [id, stage]
    );
  }

  async countByUserId(userId: string): Promise<number> {
    const result = await this.db.queryOne<{ count: string }>(
      `SELECT COUNT(*) FROM businesses WHERE user_id = $1`,
      [userId]
    );
    return parseInt(result?.count || '0');
  }

  private toBusiness(row: BusinessRow): Business {
    return {
      id: row.id,
      userId: row.user_id,
      name: row.name,
      industry: row.industry,
      stage: row.stage as BusinessStage,
      context: row.context,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
```

### Business Service

```typescript
// src/core/business/business.service.ts
import { BusinessRepository } from '../../infrastructure/repositories/business.repository';
import { Business, CreateBusinessInput, BusinessContext, BusinessStage } from '../../types';
import { ValidationError } from '../errors';

export class BusinessService {
  private activeBusiness: Business | null = null;
  private readonly MAX_BUSINESSES = {
    starter: 1,
    pro: 3,
    founder: 10,
  };

  constructor(private businessRepo: BusinessRepository) {}

  async init(userId: string): Promise<void> {
    const businesses = await this.businessRepo.findByUserId(userId);

    if (businesses.length > 0) {
      this.activeBusiness = businesses[0]; // Most recently updated
    }
  }

  async create(userId: string, input: CreateBusinessInput, tier: string = 'starter'): Promise<Business> {
    // Check limit
    const count = await this.businessRepo.countByUserId(userId);
    const limit = this.MAX_BUSINESSES[tier as keyof typeof this.MAX_BUSINESSES] || 1;

    if (count >= limit) {
      throw new ValidationError(
        `Business limit reached (${limit}). Upgrade your plan to add more.`
      );
    }

    const business = await this.businessRepo.create({
      userId,
      name: input.name,
      industry: input.industry,
      stage: input.stage,
    });

    this.activeBusiness = business;
    return business;
  }

  async switchTo(businessId: string): Promise<boolean> {
    const business = await this.businessRepo.findById(businessId);

    if (!business) {
      return false;
    }

    this.activeBusiness = this.businessRepo['toBusiness'](business);
    return true;
  }

  async list(userId: string): Promise<Business[]> {
    return this.businessRepo.findByUserId(userId);
  }

  async updateContext(context: Partial<BusinessContext>): Promise<void> {
    if (!this.activeBusiness) {
      throw new Error('No active business');
    }

    await this.businessRepo.updateContext(this.activeBusiness.id, context);

    // Update local cache
    this.activeBusiness.context = {
      ...this.activeBusiness.context,
      ...context,
    };
  }

  async updateStage(stage: BusinessStage): Promise<void> {
    if (!this.activeBusiness) {
      throw new Error('No active business');
    }

    await this.businessRepo.updateStage(this.activeBusiness.id, stage);
    this.activeBusiness.stage = stage;
  }

  getActive(): Business | null {
    return this.activeBusiness;
  }

  getActiveId(): string | null {
    return this.activeBusiness?.id || null;
  }
}
```

### CLI Commands

```typescript
// src/cli/commands/business.commands.ts
import chalk from 'chalk';
import { BusinessService } from '../../core/business/business.service';

export function registerBusinessCommands(repl: REPL, businessService: BusinessService): void {
  repl.registerCommand('/business', async (args: string) => {
    const [action, ...rest] = args.split(' ');

    switch (action) {
      case 'list':
        await listBusinesses(businessService);
        break;

      case 'new':
        await createBusiness(businessService, rest.join(' '));
        break;

      case 'switch':
        await switchBusiness(businessService, rest[0]);
        break;

      case 'info':
        showBusinessInfo(businessService);
        break;

      default:
        showBusinessHelp();
    }
  });
}

async function listBusinesses(service: BusinessService): Promise<void> {
  const businesses = await service.list(getCurrentUserId());

  if (businesses.length === 0) {
    console.log(chalk.yellow('No businesses yet. Create one with /business new <name>'));
    return;
  }

  console.log(chalk.bold('\nðŸ¢ Your Businesses\n'));

  businesses.forEach((b, i) => {
    const active = service.getActiveId() === b.id ? chalk.green(' (active)') : '';
    console.log(`  ${i + 1}. ${b.name}${active}`);
    console.log(chalk.gray(`     Stage: ${b.stage} â€¢ Industry: ${b.industry || 'Not set'}`));
    console.log(chalk.gray(`     ID: ${b.id}`));
  });
  console.log();
}

async function createBusiness(service: BusinessService, name: string): Promise<void> {
  if (!name) {
    console.log(chalk.yellow('Usage: /business new <name>'));
    return;
  }

  try {
    const business = await service.create(getCurrentUserId(), { name });
    console.log(chalk.green(`âœ“ Created business: ${business.name}`));
  } catch (error) {
    console.log(chalk.red(`Error: ${error.message}`));
  }
}

async function switchBusiness(service: BusinessService, id: string): Promise<void> {
  if (!id) {
    console.log(chalk.yellow('Usage: /business switch <id>'));
    return;
  }

  const success = await service.switchTo(id);

  if (success) {
    const active = service.getActive();
    console.log(chalk.green(`âœ“ Switched to: ${active?.name}`));
  } else {
    console.log(chalk.red('Business not found'));
  }
}

function showBusinessInfo(service: BusinessService): void {
  const business = service.getActive();

  if (!business) {
    console.log(chalk.yellow('No active business'));
    return;
  }

  console.log(chalk.bold(`\nðŸ¢ ${business.name}\n`));
  console.log(`Stage: ${formatStage(business.stage)}`);
  console.log(`Industry: ${business.industry || 'Not set'}`);

  if (business.context.targetCustomer) {
    console.log(`Target: ${business.context.targetCustomer}`);
  }

  if (business.context.challenges.length > 0) {
    console.log('\nChallenges:');
    business.context.challenges.forEach(c => console.log(`  â€¢ ${c}`));
  }

  console.log();
}

function showBusinessHelp(): void {
  console.log(`
${chalk.bold('Business Commands:')}
  /business list          List all businesses
  /business new <name>    Create new business
  /business switch <id>   Switch to business
  /business info          Show current business
`);
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 2.4.1 | Define Business types | 20 min |
| 2.4.2 | Create BusinessRepository | 45 min |
| 2.4.3 | Implement BusinessService | 45 min |
| 2.4.4 | Add business limit by tier | 20 min |
| 2.4.5 | Implement /business list | 20 min |
| 2.4.6 | Implement /business new | 20 min |
| 2.4.7 | Implement /business switch | 20 min |
| 2.4.8 | Implement /business info | 20 min |
| 2.4.9 | Link conversations to business | 30 min |
| 2.4.10 | Write unit tests | 45 min |

---

## Acceptance Criteria

- [ ] Create new business works
- [ ] List businesses works
- [ ] Switch between businesses works
- [ ] Business context persists
- [ ] Conversations linked to business
- [ ] Business limit enforced by tier
- [ ] Stage updates work
- [ ] /business commands work

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Multi-business flow tested
- [ ] Tier limits tested
- [ ] Integration tests passing

