# Feature 2.2: User Accounts & Authentication

## Metadata
| Field | Value |
|-------|-------|
| **Feature ID** | 2.2 |
| **Phase** | 2 - Persistence |
| **Priority** | Critical |
| **Estimated Effort** | 6-8 hours |
| **Dependencies** | 2.1 (PostgreSQL Setup) |
| **Approval** | [ ] |
| **Status** | Not Started |

---

## Overview

Implement user registration, login, and session management with secure password hashing and JWT tokens for API authentication.

## User Story

As a **user**, I want to **create an account and log in** so that **my data is private and persists across devices**.

---

## Requirements

### Functional Requirements
1. User registration with email/password
2. User login with email/password
3. JWT token generation
4. Token refresh mechanism
5. Password reset flow (email)
6. Logout (token invalidation)
7. /register and /login CLI commands

### Non-Functional Requirements
- bcrypt password hashing (cost 12)
- JWT expiry: 7 days
- Refresh token: 30 days
- Rate limiting on auth endpoints
- No plaintext passwords in logs

---

## Technical Specification

### User Entity

```typescript
// src/types/user.ts
export interface User {
  id: string;
  email: string;
  name: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserCredentials {
  email: string;
  password: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface TokenPayload {
  userId: string;
  email: string;
  iat: number;
  exp: number;
}
```

### Auth Service

```typescript
// src/core/auth/auth.service.ts
import * as bcrypt from 'bcrypt';
import * as jwt from 'jsonwebtoken';
import { UserRepository } from '../../infrastructure/repositories/user.repository';
import { User, UserCredentials, AuthTokens } from '../../types';
import { ValidationError, AuthError } from '../errors';

export class AuthService {
  private readonly SALT_ROUNDS = 12;
  private readonly ACCESS_TOKEN_EXPIRY = '7d';
  private readonly REFRESH_TOKEN_EXPIRY = '30d';

  constructor(
    private userRepo: UserRepository,
    private jwtSecret: string
  ) {}

  async register(credentials: UserCredentials): Promise<User> {
    // Validate email
    if (!this.isValidEmail(credentials.email)) {
      throw new ValidationError('Invalid email format');
    }

    // Check password strength
    if (credentials.password.length < 8) {
      throw new ValidationError('Password must be at least 8 characters');
    }

    // Check if user exists
    const existing = await this.userRepo.findByEmail(credentials.email);
    if (existing) {
      throw new ValidationError('Email already registered');
    }

    // Hash password
    const passwordHash = await bcrypt.hash(credentials.password, this.SALT_ROUNDS);

    // Create user
    return this.userRepo.create({
      email: credentials.email.toLowerCase(),
      passwordHash,
    });
  }

  async login(credentials: UserCredentials): Promise<AuthTokens> {
    const user = await this.userRepo.findByEmail(credentials.email.toLowerCase());

    if (!user) {
      throw new AuthError('Invalid email or password');
    }

    const isValid = await bcrypt.compare(
      credentials.password,
      user.passwordHash
    );

    if (!isValid) {
      throw new AuthError('Invalid email or password');
    }

    return this.generateTokens(user);
  }

  async refreshToken(refreshToken: string): Promise<AuthTokens> {
    try {
      const payload = jwt.verify(refreshToken, this.jwtSecret) as TokenPayload;
      const user = await this.userRepo.findById(payload.userId);

      if (!user) {
        throw new AuthError('User not found');
      }

      return this.generateTokens(user);
    } catch (error) {
      throw new AuthError('Invalid refresh token');
    }
  }

  verifyToken(token: string): TokenPayload {
    try {
      return jwt.verify(token, this.jwtSecret) as TokenPayload;
    } catch (error) {
      throw new AuthError('Invalid token');
    }
  }

  private generateTokens(user: User): AuthTokens {
    const payload = {
      userId: user.id,
      email: user.email,
    };

    const accessToken = jwt.sign(payload, this.jwtSecret, {
      expiresIn: this.ACCESS_TOKEN_EXPIRY,
    });

    const refreshToken = jwt.sign(payload, this.jwtSecret, {
      expiresIn: this.REFRESH_TOKEN_EXPIRY,
    });

    return {
      accessToken,
      refreshToken,
      expiresIn: 7 * 24 * 60 * 60, // 7 days in seconds
    };
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}
```

### User Repository

```typescript
// src/infrastructure/repositories/user.repository.ts
import { BaseRepository } from '../database/base.repository';
import { User } from '../../types';

interface UserRow {
  id: string;
  email: string;
  password_hash: string;
  name: string | null;
  created_at: Date;
  updated_at: Date;
}

export class UserRepository extends BaseRepository<UserRow> {
  constructor(db: DatabaseClient) {
    super(db, 'users');
  }

  async findByEmail(email: string): Promise<UserRow | null> {
    return this.db.queryOne<UserRow>(
      'SELECT * FROM users WHERE email = $1',
      [email.toLowerCase()]
    );
  }

  async create(data: { email: string; passwordHash: string }): Promise<User> {
    const row = await this.insert({
      email: data.email,
      password_hash: data.passwordHash,
    });

    return this.toUser(row);
  }

  private toUser(row: UserRow): User {
    return {
      id: row.id,
      email: row.email,
      name: row.name,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
```

### Token Storage (CLI)

```typescript
// src/infrastructure/storage/token-storage.ts
import * as fs from 'fs/promises';
import * as path from 'path';

export class TokenStorage {
  private tokenPath: string;

  constructor(basePath: string = '~/.bos') {
    this.tokenPath = path.join(
      basePath.replace('~', process.env.HOME || ''),
      '.auth'
    );
  }

  async saveTokens(tokens: AuthTokens): Promise<void> {
    const data = {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      savedAt: new Date().toISOString(),
    };
    await fs.writeFile(this.tokenPath, JSON.stringify(data), {
      mode: 0o600, // Read/write for owner only
    });
  }

  async loadTokens(): Promise<AuthTokens | null> {
    try {
      const content = await fs.readFile(this.tokenPath, 'utf-8');
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  async clearTokens(): Promise<void> {
    await fs.unlink(this.tokenPath).catch(() => {});
  }
}
```

### CLI Auth Commands

```typescript
// src/cli/commands/auth.commands.ts
import * as readline from 'readline';
import chalk from 'chalk';

export function registerAuthCommands(repl: REPL, auth: AuthService, tokens: TokenStorage): void {
  repl.registerCommand('/register', async () => {
    const email = await promptInput('Email: ');
    const password = await promptPassword('Password: ');
    const confirmPassword = await promptPassword('Confirm password: ');

    if (password !== confirmPassword) {
      console.log(chalk.red('Passwords do not match'));
      return;
    }

    try {
      const user = await auth.register({ email, password });
      console.log(chalk.green(`✓ Account created for ${user.email}`));

      // Auto-login after registration
      const authTokens = await auth.login({ email, password });
      await tokens.saveTokens(authTokens);
      console.log(chalk.green('✓ Logged in'));
    } catch (error) {
      console.log(chalk.red(`Error: ${error.message}`));
    }
  });

  repl.registerCommand('/login', async () => {
    const email = await promptInput('Email: ');
    const password = await promptPassword('Password: ');

    try {
      const authTokens = await auth.login({ email, password });
      await tokens.saveTokens(authTokens);
      console.log(chalk.green('✓ Logged in successfully'));
    } catch (error) {
      console.log(chalk.red(`Error: ${error.message}`));
    }
  });

  repl.registerCommand('/logout', async () => {
    await tokens.clearTokens();
    console.log(chalk.green('✓ Logged out'));
  });

  repl.registerCommand('/whoami', async () => {
    const savedTokens = await tokens.loadTokens();

    if (!savedTokens) {
      console.log(chalk.yellow('Not logged in'));
      return;
    }

    try {
      const payload = auth.verifyToken(savedTokens.accessToken);
      console.log(chalk.cyan(`Logged in as: ${payload.email}`));
    } catch {
      console.log(chalk.yellow('Session expired. Please /login again.'));
    }
  });
}

async function promptInput(prompt: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(prompt, (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

async function promptPassword(prompt: string): Promise<string> {
  // In real implementation, hide password input
  return promptInput(prompt);
}
```

---

## Tasks Breakdown

| Task | Description | Estimate |
|------|-------------|----------|
| 2.2.1 | Add bcrypt and jsonwebtoken deps | 10 min |
| 2.2.2 | Create User types | 15 min |
| 2.2.3 | Implement UserRepository | 30 min |
| 2.2.4 | Implement AuthService | 60 min |
| 2.2.5 | Add password hashing | 20 min |
| 2.2.6 | Implement JWT generation | 30 min |
| 2.2.7 | Create TokenStorage for CLI | 30 min |
| 2.2.8 | Implement /register command | 30 min |
| 2.2.9 | Implement /login command | 30 min |
| 2.2.10 | Implement /logout command | 15 min |
| 2.2.11 | Add auto-refresh on expiry | 30 min |
| 2.2.12 | Write unit tests | 60 min |

---

## Acceptance Criteria

- [ ] User can register with email/password
- [ ] Duplicate email rejected
- [ ] Password validated (min 8 chars)
- [ ] User can login
- [ ] Invalid credentials rejected
- [ ] JWT token generated on login
- [ ] Token stored securely (600 permissions)
- [ ] /whoami shows current user
- [ ] /logout clears session
- [ ] Token refresh works

---

## Dependencies (npm)

```json
{
  "dependencies": {
    "bcrypt": "^5.1.0",
    "jsonwebtoken": "^9.0.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.0"
  }
}
```

---

## Security Considerations

- Passwords hashed with bcrypt (cost 12)
- JWT secret from environment variable
- Token file permissions: 600
- No passwords in logs
- Rate limiting (future: 2.6)

---

## Definition of Done

- [ ] All tasks completed
- [ ] All acceptance criteria met
- [ ] Security review passed
- [ ] Tests passing
- [ ] No passwords logged

